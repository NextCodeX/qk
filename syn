#####demo.qk#####println("hi, \"joker\" \n")

a = 1
b = 3
c = 7 + a * b
if b > 0 {
    println("b 大于 0")
}
println("c:", c)

add(n1, n2) {
    res = n1 + n2
    return n3
}
d = add(13, 23)
println("add result:", d)

arr = [1, true, "testing"]
println("a len:", a.len)
println("a[1]", a[1])
arr.add("hello world")
println("a len:", a.len)

obj = {
name: "tome",
age: 18
}
println("user age:", obj.age)
println("user name:", obj["name"])


~~~~~~~~~~~~~~~~~~~~
#####expr.qk#####a = 9
println(a)~~~~~~~~~~~~~~~~~~~~
#####src\core\compile.go#####package core

import (
    "fmt"
    "strconv"
)

var (
    funcList = make(map[string]*Function)
    mainFunc = newFunc("main")
)


func Compile(stmts StatementList, ts []Token) {
    if stmts.isCompiled() {
        return
    }else {
        stmts.setCompiled(true)
    }
    extractStatement(stmts, ts)
    parseStatementList(stmts.stmts())

    for _, customFunc := range funcList {
       Compile(customFunc, customFunc.getRaw())
    }
}

func extractStatement(stmts StatementList, ts []Token) {
    stmts.setRaw(ts)
    for i := 0; i < len(ts); {
        t := ts[i]
        var endIndex int
        var stmt *Statement

        if !t.isIdentifier() && !t.isComplex() {
            goto next_loop
        }
        switch t.str {
        case "if":
            stmt, endIndex = parseIfStatement(i, ts)
        case "for":
            stmt, endIndex = parseForStatement(i, ts)
        case "switch":
        case "return":
            stmt, endIndex = parseReturnStatement(i, ts)
        default:
            if t.isFdef() {
                f, endIndex1 := parseFunction(i, ts)
                funcList[f.name] = f
                i = endIndex1
                goto next_loop
            }
            endIndex = nextBoundary(i, ts)
            if endIndex > 0 {
                stmt = newStatement(ExpressionStatement, ts[i:endIndex])
            }
        }
        if endIndex > 0 {
            stmts.addStatement(stmt)
            i = endIndex
        }

    next_loop:
        i++
    }
}

func parseReturnStatement(currentIndex int, ts []Token) (*Statement, int) {
    stmt := &Statement{t:ReturnStatement}
    size := len(ts)
    var endIndex int
    for i:=currentIndex+1; i<size; i++ {
        t := ts[i]
        if t.assertSymbols("}", ";") {
            endIndex = i
            break
        }

        stmt.raw = append(stmt.raw, t)

        if i==size-1 {
            endIndex = i
        }
    }
    return stmt, endIndex
}

func parseFunction(currentIndex int, ts []Token) (*Function, int) {
    var nextIndex int
    f := newFunc(ts[currentIndex].str)
    f.defToken = ts[currentIndex]
    var blockTokens []Token
    size := len(ts)
    scopeOpenCount := 1
    for i:=currentIndex+2; i<size; i++ {
        token := ts[i]
        if token.assertSymbol("{") {
            scopeOpenCount ++
        }
        if token.assertSymbol("}") {
            scopeOpenCount --
            if scopeOpenCount == 0 {
                nextIndex = i
                break
            }
        }
        blockTokens = append(blockTokens, token)
    }
    if scopeOpenCount > 0 {
        panic("parse function statement exception!")
    }
    f.setRaw(blockTokens)
    return f, nextIndex
}

func parseIfStatement(currentIndex int, ts []Token) (*Statement, int) {
    stmt := &Statement{t:IfStatement}

    index := nextSymbol(currentIndex, ts, "{")
    stmt.condition = &Expression{
        t:     BinaryExpression,
        raw:   ts[currentIndex+1:index],
    }

    scopeOpenCount := 1
    var endIndex int
    for i:=index+1; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol("{") {
            scopeOpenCount++
        }
        if t.assertSymbol("}") {
            scopeOpenCount--
            if scopeOpenCount == 0 {
                endIndex = i
                break
            }
        }
        stmt.raw = append(stmt.raw, t)
    }
    return stmt, endIndex
}

func parseForStatement(currentIndex int, ts []Token) (*Statement, int) {
    stmt := &Statement{t:IfStatement}
    index := nextSymbol(currentIndex, ts, "{")
    exprs := splitExpression(ts[currentIndex+1:index])
    stmt.setHeaderInfo(exprs)
    scopeOpenCount := 1
    var endIndex int
    for i:=index+1; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol("{") {
            scopeOpenCount++
        }
        if t.assertSymbol("}") {
            scopeOpenCount--
            if scopeOpenCount == 0 {
                endIndex = i
                break
            }
        }
        stmt.raw = append(stmt.raw, t)
    }
    return stmt, endIndex
}

func splitExpression(ts []Token) []*Expression {
    res := make([]*Expression, 3)
    size := len(ts)
    // for语句没用";"分隔，表达式即为condition expression
    if !hasSymbol(ts, ";") {
        res[1] = &Expression{
            t:     BinaryExpression,
            raw:   ts,
        }
        return res
    }

    //for 语句存在";"分隔符时
    // extract initialize expression
    index := nextSymbol(0, ts, ";")
    if index > 2 {
        res[0] = &Expression{
            t:     BinaryExpression,
            raw:   ts[:index],
        }
    }

    // extract condition expression
    preIndex := index+1
    index = nextSymbol(preIndex, ts, ";")
    if index - preIndex > 2 {
        res[1] = &Expression{
            t:     BinaryExpression,
            raw:   ts[preIndex:index],
        }
    } else if preIndex<size && !hasSymbol(ts[preIndex:], ";") {
        res[1] = &Expression{
            t:     BinaryExpression,
            raw:   ts[preIndex:],
        }
        index = size
    }

    // extract post expression
    preIndex = index+1
    if preIndex < size {
        res[2] = &Expression{
            t:     BinaryExpression,
            raw:   ts[preIndex:],
        }
    }
    return res
}


func nextBoundary(currentIndex int, ts []Token) int {
    return nextSymbol(currentIndex, ts, ";")
}

func nextSymbol(currentIndex int, ts []Token, s string) int {
    for i:=currentIndex; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol(s) {
            return i
        }
    }
    return -1
}

func hasSymbol(ts []Token, s string) bool {
    for i:=0; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol(s) {
            return true
        }
    }
    return false
}


func parseStatementList(stmts []*Statement) {
    for _, stmt := range stmts {
        parseStatement(stmt)
    }
}

func parseStatement(stmt *Statement) {
    ts := stmt.raw
    switch {
    case stmt.isExpressionStatement():
        expr := parseExpressionStatement(ts)
        stmt.addExpression(expr)

    case stmt.isIfStatement():
    case stmt.isForStatement():
    case stmt.isSwitchStatement():
    case stmt.isReturnStatement():
    }
}

func parseExpressionStatement(ts []Token) *Expression {
    var expr *Expression
    tlen := len(ts)
    // 去括号
    if tlen >= 3 && ts[0].assertSymbol("(") && ts[tlen-1].assertSymbol(")")  {
        ts = ts[1:tlen-1]
    }
    tlen = len(ts)
    if tlen < 1 {
        return expr
    }
    switch {
    case tlen == 1:
        return parseUnaryExpression(ts)
    case tlen == 2:
        if !ts[0].isIdentifier() {
            return expr
        }
        parseUnaryPlusExpression(ts)

    case tlen == 3:
        expr = parseBinaryExpression(ts)

    case tlen == 5:
        parseTernaryExpression(ts)
    default:
        // 处理多维表达式
        //expr, next := parseMultivariateExpression(ts, stmt)
        //if expr != nil {
            //stmt.addExpression(expr)
        //}
        //if next != nil {
        //    parseExpressionStatement(next, stmt)
        //}
    }
    return expr
}

func parseTernaryExpression(ts []Token) {
    
}

func parseUnaryPlusExpression(ts []Token) {
    if ts[1].assertSymbol("++") {

    }else if ts[2].assertSymbol("--") {

    }
}

func parseUnaryExpression(ts []Token) *Expression {
    fmt.Println("do parseUnaryExpression: ")

    token := ts[0]
    fmt.Println(token.String(), ":", token.isFcall())
    expr := &Expression{}
    primaryExpr := parsePrimaryExpression(&token)
    expr.left = primaryExpr
    if token.isStr() {
        expr.t = StringExpression | ConstExpression
        return expr
    }
    if token.isInt() {
        expr.t = IntExpression | ConstExpression
        return expr
    }
    if token.isFloat() {
        expr.t = FloatExpression | ConstExpression
        return expr
    }
    if token.isIdentifier() {
        if primaryExpr.isVar() {
            expr.t = VarExpression
        } else {
            expr.t = BooleanExpression
        }
        return expr
    }
    if token.isFcall() {
        expr.t = FunctionCallExpression
        return expr
    }
    //primaryExpr :=
    return nil
}

func parseMultivariateExpression(ts []Token, stmt *Statement) (*Expression, []Token) {
    first := ts[0]
    mid := ts[1]
    third := ts[2]
    fourth := ts[3]
    var expr *Expression
    if first.isIdentifier() && mid.str == "=" {
        if first.isTmp() && len(ts) == 5 {
            fifth := ts[4]
            exprType := getExpressionType(fourth.str)
            expr = &Expression{
                t:          exprType,
                left:       parsePrimaryExpression(&third),
                right:      parsePrimaryExpression(&fifth),
                tmpname:    first.str,
            }
            return expr, nil
        }

        expr = newMultiExpression()
        tmp := &Expression{
            t:     TmpExpression,
            left:  &PrimaryExpr{},
            right: &PrimaryExpr{},
        }
        expr.list = append(expr.list, tmp)

        return expr, ts[3:]
    }
    b11 := isMulDiv(mid.str)
    b12 := isAddSub(mid.str) && isAddSub(fourth.str)
    if b11 || b12 {
        exprType := getExpressionType(mid.str)
        tmpname := getTmpname(stmt)
        expr = &Expression{
            t:          TmpExpression | exprType,
            left:       parsePrimaryExpression(&first),
            right:      parsePrimaryExpression(&third),
            tmpname:    tmpname,
        }
        head := tmpToken(tmpname)
        next := insert(head, ts[3:])
        return expr, next
    }
    if isAddSub(mid.str) && isMulDiv(fourth.str) {
        exprType := getExpressionType(mid.str)
        tmpname := getTmpname(stmt)
        tail := tmpToken(tmpname)
        expr = &Expression{
            t:          TmpExpression | exprType,
            left:       parsePrimaryExpression(&first),
            right:      parsePrimaryExpression(&tail),
        }
        assignToken := symbolToken("=")
        next := insert2(tail, assignToken, ts[2:])
        return expr, next
    }
    return nil, nil
}

func isAddSub(op string) bool {
    return op == "+" || op == "-"
}

func isMulDiv(op string) bool {
    return op == "*" || op == "/"
}

func getTmpname(stmt *Statement) string {
    name := fmt.Sprintf("tmp.%v", stmt.tmpcount)
    stmt.tmpcount++
    return name
}

func parseBinaryExpression(ts []Token) *Expression {
    first := ts[0]
    mid := ts[1]
    third := ts[2]
    left := parsePrimaryExpression(&first)
    right := parsePrimaryExpression(&third)
    var op OperationType
    switch {
    case  first.isIdentifier() && mid.assertSymbol("="):
        op = Opassign

    case mid.str == "+":
        op = Opadd

    case mid.str == "-":
        op = Opsub

    case mid.str == "*":
        op = Opmul

    case mid.str == "/":
        op = Opdiv

    default:
        return nil
    }

    expr := &Expression{
        t:     BinaryExpression,
        op:    op,
        left:  left,
        right: right,
    }
    return expr
}

func getExpressionType(op string) ExpressionType {
    switch op {

    default:
        return -1
    }
}

func parsePrimaryExpression(t *Token) *PrimaryExpr {
    v := tokenToValue(t)
    var res *PrimaryExpr
    if v != nil {
        res = &PrimaryExpr{res:v}
    } else if t.isFcall() {
        exprs := getArgsFromToken(t.ts)
        res = &PrimaryExpr{name:t.str, args: exprs}
    } else {
        res = &PrimaryExpr{t:VarPrimaryExpressionType, name:t.str}
    }
    return res
}

func getArgsFromToken(ts []Token) []*Expression {
    var res []*Expression
    size := len(ts)
    if size < 1 {
        return res
    }
    if size == 1 {
        expr := parseExpressionStatement(ts)
        res = append(res, expr)
        return res
    }
    return res
}

func tokenToValue(t *Token) *Value {
    var v Value
    if t.isFloat() {
        f, err := strconv.ParseFloat(t.str, 64)
        exitOnError(err)
        v = newVal(f)
        return &v
    }
    if t.isInt() {
        i, err := strconv.Atoi(t.str)
        exitOnError(err)
        v = newVal(i)
        return &v
    }
    if t.isStr() {
        v = newVal(fmt.Sprintf("%v", t.str))
        return &v
    }
    if t.str == "true" || t.str == "false" {
        b, err := strconv.ParseBool(t.str)
        exitOnError(err)
        v = newVal(b)
        return &v
    }
    return nil
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\expression.go#####package core

import (
    "bytes"
)

type ExpressionType int

const (
    IntExpression ExpressionType = 1 << iota
    FloatExpression
    BooleanExpression
    StringExpression
    ConstExpression
    VarExpression
    FunctionCallExpression
    MethodCallExpression
    BinaryExpression
    MultiExpression
    TmpExpression
)

type OperationType int

const (
    Opeq OperationType = 1 << iota
    Opgt
    Oplt
    Opge
    Ople
    Opadd
    Opsub
    Opmul
    Opdiv
    Opassign
)


type Expression struct {
    t ExpressionType
    op OperationType
    left *PrimaryExpr
    right *PrimaryExpr
    list []*Expression
    listFinish bool
    raw []Token
    res *Value
    tmpname string
}

func (this *Expression) isAssign() bool {
    return (this.op & Opassign) == Opassign
}

func newMultiExpression() *Expression {
    return &Expression{
        t:          MultiExpression,
        listFinish: false,
    }
}

func (this *Expression) isIntExpression() bool {
    return (this.t & IntExpression) == IntExpression
}

func (this *Expression) isFloatExpression() bool {
    return (this.t & FloatExpression) == FloatExpression
}

func (this *Expression) isBooleanExpression() bool {
    return (this.t & BooleanExpression) == BooleanExpression
}

func (this *Expression) isStringExpression() bool {
    return (this.t & StringExpression) == StringExpression
}

func (this *Expression) isConstExpression() bool {
    return (this.t & ConstExpression) == ConstExpression
}

func (this *Expression) isVarExpression() bool {
    return (this.t & VarExpression) == VarExpression
}

func (this *Expression) isFunctionCallExpression() bool {
    return (this.t & FunctionCallExpression) == FunctionCallExpression
}

func (this *Expression) isBinaryExpression() bool {
    return (this.t & BinaryExpression) == BinaryExpression
}

func (this *Expression) isMultiExpression() bool {
    return (this.t & MultiExpression) == MultiExpression
}

func (this *Expression) isTmpExpression() bool {
    return (this.t & TmpExpression) == TmpExpression
}



func (expr *Expression) String() string {
    if expr == nil {
        return ""
    }
    var res bytes.Buffer
    for _, t := range expr.raw {
        res.WriteString(t.String())
        res.WriteString(" ")
    }
    return res.String()
}

type PrimaryExpressionType int
const (
    VarPrimaryExpressionType PrimaryExpressionType = 1 << iota
    ConstPrimaryExpressionType
    OtherPrimaryExpressionType PrimaryExpressionType = 0
)

type PrimaryExpr struct {
    t PrimaryExpressionType
    caller string // 调用者名称
    name string  // 变量名或者函数名称
    args []*Expression // 参数变量名
    res *Value  // 常量值
}

func (this *PrimaryExpr) isVar() bool {
    return (this.t & VarPrimaryExpressionType) == VarPrimaryExpressionType
}

func (this *PrimaryExpr) isOther() bool {
    return (this.t & OtherPrimaryExpressionType) == OtherPrimaryExpressionType
}

~~~~~~~~~~~~~~~~~~~~
#####src\core\index.go#####package core

import (
    "fmt"
    "io/ioutil"
    "os/exec"
    "runtime"
    "strings"
)

func Run() {
    //qkfile := "demo.qk"
    qkfile := "expr.qk"
    bs, _ := ioutil.ReadFile(qkfile)
    ts := Parse(bs)
    printTokens(ts)
    Compile(mainFunc, ts)
    printFunc()
    fmt.Println("================")
    Interpret()
}

func printFunc() {
    doPrintFunc(mainFunc)
    for _, fn := range funcList {
        doPrintFunc(fn)
    }
}

func doPrintFunc(fn *Function) {
    fmt.Println("######################", fn.name, len(fn.block))
    for i, stmt := range fn.block {
        fmt.Printf("num: %v line %v: \n %v \n", len(stmt.raw), i, stmt)
    }
}

func printTokens(tokens []Token) {
    for i, token := range tokens {
        fmt.Printf("line %v: [%v] -> %v \n", i, token.String(), token.TokenTypeName())
    }
}

// 获取命令所在的路径
func getCmdDir() string {
    cmd := exec.Command( "cmd", "/c", "cd")
    if runtime.GOOS != "windows" {
        cmd = exec.Command("pwd")
    }
    d, err := cmd.CombinedOutput()
    exitOnError(err)
    pwd := strings.TrimSpace(string(d))
    return pwd
}


~~~~~~~~~~~~~~~~~~~~
#####src\core\interpreter.go#####package core

import "fmt"

func Interpret() {
    for _, stmt := range mainFunc.block {
        local := newVariables()
        executeStatement(stmt, newVarScope(nil, &local))
    }
}

func executeStatement(stmt *Statement, vars *VarScope) *StatementResultType {
    if stmt.isExpressionStatement() {
        for _, expr := range stmt.exprs {
            executeExpression(expr, vars)
        }
    }

    return nil
}

func executeExpression(expr *Expression, vars *VarScope) (res *Value) {
    if expr.isConstExpression() {
        return expr.left.res
    }
    if expr.isVarExpression() {
        varname := expr.left.name

        variable := searchVariable(varname, vars)
        fmt.Println("after searchVariable:", variable)

        //return &(variable.val)
    }
    if expr.isBinaryExpression() {
        return executeBinaryExpression(expr, vars)
    }
    if expr.isFunctionCallExpression() {
        return executeFunctionCallExpression(expr, vars)
    }

    return
}

func executeFunctionCallExpression(expr *Expression, vars *VarScope) (res *Value) {
    functionName := expr.left.name
    args := expr.left.args
    if functionName == "println" {
        argVals := toGoTypeValues(args, vars)
        if len(argVals) < 1 {
            fmt.Println()
        }else{
            fmt.Println(argVals...)
        }
    }
    return nil
}

func executeBinaryExpression(expr *Expression, vars *VarScope) (res *Value) {
    switch {
    case expr.isAssign():
        varname := expr.left.name
        val := expr.right.res
        variable := toVar(varname, *val)
        vars.local.add(variable)
    }
    return nil
}

func searchVariable(name string, vars *VarScope) *Variable {
    fmt.Println("searchVariable:", name, vars.local.isEmpty())
    res := vars.local.get(name)
    if res != nil {
        return res
    }
    res = vars.super.get(name)
    if res != nil {
        return res
    }
    return nil
}

func toGoTypeValues(exprs []*Expression, vars *VarScope) []interface{} {
    var res []interface{}
    for _, expr := range exprs {
        v := executeExpression(expr, vars).val()
        res = append(res, v)
    }
    return res
}

~~~~~~~~~~~~~~~~~~~~
#####src\core\lex.go#####package core

import (
    "bytes"
    "fmt"
    "strings"
)

type TokenType int
const (
    Identifier  TokenType = 1 << iota // 标识符
    Str // 字符串类型
    Int // 整数类型
    Float  // 浮点类型
    Symbol  // 符号

    Fcall  // 函数调用
    Fdef  // 函数 定义
    Mtcall // 方法调用
    Attribute // 对象属性
    ArrLiteral // 数组字面值
    ObjLiteral // 对象字面值
    Element // 元素，用于指示对象或数组的元素
    Complex // 用于标记复合类型token

    Tmp // 语法分析时，插入的临时变量名
)

const (
    stateStr int = 1 << iota
    stateStrLiteral
    stateInt
    stateDot
    stateFloat
    stateSymbol
    stateSpace
    normal
)

type Token struct {
    str string
    t TokenType
    caller string
    ts []Token
}

func newToken(raw string, t TokenType) Token {
    return Token{str:raw,t:t}
}

func symbolToken(s string) Token {
    return Token{str:s, t:Symbol}
}

func tmpToken(raw string) Token {
    return Token{str:raw, t:Tmp | Identifier}
}

func (this *Token) isIdentifier() bool {
    return (this.t & Identifier) == Identifier
}

func (this *Token) isStr() bool {
    return (this.t & Str) == Str
}

func (this *Token) isInt() bool {
    return (this.t & Int) == Int
}

func (this *Token) isFloat() bool {
    return (this.t & Float) == Float
}

func (this *Token) isSymbol() bool {
    return (this.t & Symbol) == Symbol
}

func (this *Token) isTmp() bool {
    return (this.t & Tmp) == Tmp
}

func (this *Token) isFdef() bool {
    return (this.t & Fdef) == Fdef
}

func (this *Token) isFcall() bool {
    return (this.t & Fcall) == Fcall
}

func (this *Token) isAttribute() bool {
    return (this.t & Attribute) == Attribute
}

func (this *Token) isMtcall() bool {
    return (this.t & Mtcall) == Mtcall
}

func (this *Token) isArrLiteral() bool {
    return (this.t & ArrLiteral) == ArrLiteral
}

func (this *Token) isObjLiteral() bool {
    return (this.t & ObjLiteral) == ObjLiteral
}

func (this *Token) isElement() bool {
    return (this.t & Element) == Element
}

func (this *Token) isComplex() bool {
    return (this.t & Complex) == Complex
}

func (this *Token) assertSymbol(s string) bool {
    return this.isSymbol() && this.str == s
}

func (this *Token) assertSymbols(ss ...string) bool {
    if !this.isSymbol(){
        return false
    }
    for _, s := range ss {
        if s == this.str {
            return true
        }
    }
    return false
}

func (this *Token) String() string {
    if this.isArrLiteral() {
        var buf bytes.Buffer
        buf.WriteString("[")
        if this.ts != nil {
            for _, token := range this.ts {
                if token.isStr() {
                    buf.WriteString(fmt.Sprintf(`"%v"`, token.str))
                } else {
                    buf.WriteString(token.str)
                }
            }
        }
        buf.WriteString("]")
        return buf.String()
    }

    if this.isObjLiteral() {
        var buf bytes.Buffer
        buf.WriteString("{")
        if this.ts != nil {
            for _, token := range this.ts {
                if token.isStr() || token.isIdentifier() {
                    buf.WriteString(fmt.Sprintf(`"%v"`, token.str))
                } else {
                    buf.WriteString(token.str)
                }
            }
        }
        buf.WriteString("}")
        return buf.String()
    }

    if this.isFcall() || this.isFdef() {
        var buf bytes.Buffer
        buf.WriteString(this.str)
        buf.WriteString("(")
        if this.ts != nil {
            for _, token := range this.ts {
                buf.WriteString(token.String())
            }
        }
        buf.WriteString(")")
        return buf.String()
    }

    if this.isAttribute() || this.isMtcall() {
        var buf bytes.Buffer
        buf.WriteString(this.caller)
        buf.WriteString(".")
        buf.WriteString(this.str)
        if this.isMtcall() {
            buf.WriteString("(")
            if this.ts != nil {
                for _, token := range this.ts {
                    buf.WriteString(token.String())
                }
            }
            buf.WriteString(")")
        }
        return buf.String()
    }

    if this.isElement() {
        var buf bytes.Buffer
        buf.WriteString(this.str)
        buf.WriteString("[")
        if this.ts != nil {
            for _, token := range this.ts {
                buf.WriteString(token.String())
            }
        }
        buf.WriteString("]")
        return buf.String()
    }

    if this.isStr() {
        return fmt.Sprintf(`"%v"`, this.str)
    }

    return this.str
}

func (t *Token) TokenTypeName() string {
    var buf bytes.Buffer
    if t.isStr() {
        buf.WriteString( "string, ")
    }
    if t.isIdentifier() {
        buf.WriteString( "identifier, ")
    }
    if t.isInt() {
        buf.WriteString( "int, ")
    }
    if t.isFloat() {
        buf.WriteString( "float, ")
    }
    if t.isSymbol() {
        buf.WriteString( "symbol, ")
    }
    if t.isFdef() {
        buf.WriteString("function define, ")
    }
    if t.isFcall() {
        buf.WriteString("function call, ")
    }
    if t.isMtcall() {
        buf.WriteString("method call, ")
    }
    if t.isAttribute() {
        buf.WriteString("attribute, ")
    }
    if t.isArrLiteral() {
        buf.WriteString("array literal, ")
    }
    if t.isObjLiteral() {
        buf.WriteString("object literal, ")
    }
    if t.isElement() {
        buf.WriteString("element, ")
    }
    if t.isComplex() {
        buf.WriteString("complex, ")
    }
    if buf.Len() == 0 {
        return "undefined"
    }
    return strings.TrimRight(strings.TrimSpace(buf.String()), ",")
}

func toString4Tokens(ts []Token, start, end int) string {
    var buf bytes.Buffer
    for i:=start; i<=end; i++ {
        token := ts[i]
        buf.WriteString(token.String()+" ")
    }
    return buf.String()
}

func printCurrentPositionTokens(ts []Token, currentIndex int) string {
    size := len(ts)
    start := 0
    if currentIndex > 10 {
        start = currentIndex - 10
    }
    end := currentIndex
    if currentIndex+1 < size {
        end = currentIndex+1
    }
    return toString4Tokens(ts, start, end)
}

func Parse(bs []byte) []Token {
    // token 初步处理
    ts := preparse(bs)
    // 去掉无用的';', 合并token生成函数调用token(Fcall), 方法调用token(Mtcall)等复合token
    ts = doparse(ts)
    return ts
}

// 该函数用于： 去掉无用的';', 合并token生成函数调用token(Fcall), 方法调用token(Mtcall)等复合token
func doparse(ts []Token) []Token {
    var res []Token
    size := len(ts)
    for i:=0; i<size; {
        token := ts[i]
        pre, preExist := preToken(i, ts)
        next, nextExist := nextToken(i, ts)
        var t Token
        var nextIndex int

        // 处理无用分号
        if token.str == ";" && ((preExist && pre.assertSymbols("{","}")) || (nextExist && next.assertSymbols("{", ";"))) {
            goto end_current_iterate
        }

        // 捕获数组的字面值Token
        if token.assertSymbol("[") && preExist && pre.assertSymbols("=", "(") {
            t, nextIndex = extractArrayLiteral(i+1, ts)
            if nextIndex > i {
                res = append(res, t)
                i = nextIndex
                goto next_loop
            }
        }
        // 捕获对象的字面值Token
        if token.assertSymbol("{") && preExist && pre.assertSymbols("=", "(") {
            t, nextIndex = extractObjectLiteral(i+1, ts)
            if nextIndex > i {
                res = append(res, t)
                i = nextIndex
                goto next_loop
            }
        }

        if !token.isIdentifier() || !nextExist {
            goto token_collect
        }

        // 捕获Attribute类型token
        t, nextIndex = extractAttribute(i, ts)
        if nextIndex > i {
            // 捕获Mtcall类型token
            if ts[nextIndex].assertSymbol("(") {
                t, nextIndex = extractMethodCall(i, ts)
            }
            res = append(res, t)
            i = nextIndex
            goto next_loop
        }

        // 捕获Fcall类型token
        t, nextIndex = extractFunctionCall(i, ts)
        if nextIndex > i {
            // 标记Fdef类型token
            if ts[nextIndex].assertSymbol("{") {
                t.t = Fdef | t.t
            }
            res = append(res, t)
            i = nextIndex
            goto next_loop
        }

        // 捕获Attribute类型token
        t, nextIndex = extractElement(i, ts)
        if nextIndex > i {
            res = append(res, t)
            i = nextIndex
            goto next_loop
        }

        // token 原样返回
        token_collect:
        res = append(res, token)

        end_current_iterate:
        i++
        next_loop:
    }
    return res
}

func extractArrayLiteral(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    scopeOpenCount := 1
    var elems []Token
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("]") {
            scopeOpenCount --
            nextIndex = i + 1
            break
        }
        if token.isSymbol() && !match(token.str, ",") {
            msg := printCurrentPositionTokens(ts, i)
            panic("extract ArrayLiteral Exception, illegal character:" + msg)
        }
        elems = append(elems, token)
    }
    if scopeOpenCount > 0 {
        panic("extract ArrayLiteral Exception: no match final character \"]\"")
    }
    t = Token{
        str:    "[]",
        t:      ArrLiteral | Complex,
        ts:     elems,
    }
    return t, nextIndex
}

func extractObjectLiteral(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    scopeOpenCount := 1
    var elems []Token
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("{") {
            scopeOpenCount ++
        }
        if token.assertSymbol("}") {
            scopeOpenCount --
            if scopeOpenCount == 0 {
                nextIndex = i + 1
                break
            }
        }
        if token.isSymbol() && !match(token.str,",", ":", "[", "]", "{", "}") {
            msg := printCurrentPositionTokens(ts, i)
            panic("extract element ObjectLiteral, illegal character: " + msg + " -type " + token.TokenTypeName())
        }
        elems = append(elems, token)
    }
    if scopeOpenCount > 0 {
        panic("extract element ObjectLiteral: no match final character \"}\"")
    }
    t = Token{
        str:    "{}",
        t:      ObjLiteral | Complex,
        ts:     elems,
    }
    return t, nextIndex
}

func extractElement(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    // 检测不符合元素定义直接返回
    if size - currentIndex < 3 || !ts[currentIndex+1].assertSymbol("[") {
        return
    }
    var indexs []Token
    extractElementIndexTokens(currentIndex+2, ts, &nextIndex, &indexs)

    t = Token {
        str:    ts[currentIndex].str,
        t:      Attribute | Complex,
        ts:     indexs,
    }
    return t, nextIndex
}

func extractElementIndexTokens(currentIndex int, ts []Token, nextIndex *int, indexs *[]Token) {
    size := len(ts)
    scopeOpenCount := 1
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("]") {
            scopeOpenCount --
            *nextIndex = i + 1
            break
        }
        if isIllegalElementIndexToken(token) {
            panic("extract element index Exception, illegal character:"+token.str)
        }
        *indexs = append(*indexs, token)
    }
    if scopeOpenCount > 0 {
        panic("extract element index Exception: no match final character \"]\"")
    }
    if ts[*nextIndex].assertSymbol("[") {
        *indexs = append(*indexs, symbolToken(","))
        extractElementIndexTokens(*nextIndex+1, ts, nextIndex, indexs)
    }
}

func extractFunctionCall(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    // 检测不符合函数调用定义直接返回
    if size - currentIndex < 3 || !ts[currentIndex+1].assertSymbol("(") {
        return
    }

    args, nextIndex := getCallArgsTokens(currentIndex + 2, ts)

    t = Token{
        str:    ts[currentIndex].str,
        t:      Fcall | Complex,
        ts:     args,
    }
    return t, nextIndex
}

func extractMethodCall(currentIndex int, ts []Token) (t Token, nextIndex int) {
    args, nextIndex := getCallArgsTokens(currentIndex + 4, ts)

    t = Token{
        str:    ts[currentIndex+2].str,
        t:      Mtcall | Complex,
        caller: ts[currentIndex].str,
        ts:     args,
    }
    return t, nextIndex
}

func getCallArgsTokens(currentIndex int, ts []Token) (args []Token, nextIndex int) {
    size := len(ts)
    scopeOpenCount := 1
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("(") {
            scopeOpenCount ++
        }
        if token.assertSymbol(")") {
            scopeOpenCount --
            if scopeOpenCount == 0 {
                nextIndex = i + 1
                break
            }
        }
        if isIllegalFcallArgsToken(token) {
            panic("extract call args Exception, illegal character:"+token.str)
        }
        args = append(args, token)
    }
    if scopeOpenCount > 0 {
        panic("extract call args Exception: no match final character \")\"")
    }
    return args, nextIndex
}

// 元素索引里的非法符号
// 函数，方法调用时参数列表里的非法符号
func isIllegalElementIndexToken(t Token) bool {
    if !t.isSymbol() {
        return false
    }
    switch t.str {
    case "{", "}", ",", ";", "[", "=":
        return true
    }
    return false
}

// 函数，方法调用时参数列表里的非法符号
func isIllegalFcallArgsToken(t Token) bool {
    if !t.isSymbol() {
        return false
    }
    switch t.str {
    case "{", "}", ";", "=":
        return true
    }
    return false
}

func extractAttribute(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    if size - currentIndex < 3 {
        return
    }
    if !ts[currentIndex+1].assertSymbol(".")  || !ts[currentIndex+2].isIdentifier() {
        return
    }
    token := Token{
        str:    ts[currentIndex+2].str,
        t:      Attribute | Complex,
        caller: ts[currentIndex].str,
    }
    return token, currentIndex+3
}

func preToken(currentIndex int, ts []Token) (t Token, ok bool) {
    if currentIndex-1 < 0 {
        return
    }
    return ts[currentIndex-1], true
}

func lastToken(ts []Token) (t Token, ok bool) {
    size := len(ts)
    if size < 1 {
        return
    }
    return ts[size-1], true
}

func nextToken(currentIndex int, ts []Token) (t Token, ok bool) {
    if currentIndex+1>=len(ts) {
        return
    }
    return ts[currentIndex+1], true
}

func preparse(bs []byte) []Token {
    var tokens []Token
    var tmp []byte
    state := normal
    for _, b := range bs {

        if state == stateStrLiteral && b != '"' {
            tmp = append(tmp, b)
            continue
        }

        switch {
        case (b>='a' && b<='z') || (b>='A' && b<='Z') || b=='_':
            tmp = append(tmp, b)
            state = stateStr
        case b>='0' && b<='9':
            tmp = append(tmp, b)
            if state == stateDot {
                state = stateFloat
            }else{
                state = stateInt
            }

        case b==' ' || b=='\t' || b =='\n':
            longTokenSave(b, state, &tmp, &tokens)

            if b=='\n' {
                addBoundry(&tokens)
            }
            state = stateSpace

        case isSymbol(b):
            if b == '.' && state==stateInt {
                tmp = append(tmp, b)
                state = stateDot
                break
            }

            longTokenSave(b, state, &tmp, &tokens)

            symbol := symbolToken(string(b))
            last, lastExist := lastToken(tokens)
            if symbol.assertSymbol("}") && lastExist && last.assertSymbol(";") {
                // 去掉无用的";"
                tokens[len(tokens)-1] = symbol
            } else {
                tokens = append(tokens, symbol)
            }
            state = stateSymbol

        case b == '"':
            if len(tmp) < 1 {
                state = stateStrLiteral
            } else {
                if tmp[len(tmp)-1] != '\\' {
                    longTokenSave(b, state, &tmp, &tokens)
                    state = normal
                } else {
                    tmp = append(tmp, b)
                }
            }

        }
    }
    longTokenSave('\n', state, &tmp, &tokens)
    addBoundry(&tokens)

    return tokens
}

func addBoundry(ts *[]Token) {
    size := len(*ts)
    if size>0 && (*ts)[size-1].assertSymbols("{", ",", "}") {
        // 防止添加无用的";"
        return
    }

    *ts = append(*ts, Token{
        str: ";",
        t:   Symbol,
    })
}

func longTokenSave(b byte, state int, tmp *[]byte, tokens *[]Token) {
    s := string(*tmp)
    if len(s) < 1 {
        return
    }

    var tokenType TokenType
    if state == stateFloat {
        tokenType = Float
    }
    if state == stateInt && b != '.' {
        tokenType = Int
    }
    if state == stateStr {
        tokenType = Identifier
    }
    if state == stateStrLiteral {
        tokenType = Str
    }
    *tokens = append(*tokens, Token{
        str: s,
        t:   tokenType,
    })
    // 重置临时变量
    *tmp = nil
}

func isSymbol(b byte) bool {
    switch b {
    case '.': fallthrough
    case ':': fallthrough
    case '(': fallthrough
    case ')': fallthrough
    case '[': fallthrough
    case ']': fallthrough
    case '{': fallthrough
    case '}': fallthrough
    case ';': fallthrough
    case ',': fallthrough
    case '=': fallthrough
    case '+': fallthrough
    case '-': fallthrough
    case '*': fallthrough
    case '/': fallthrough
    case '%': fallthrough
    case '>': fallthrough
    case '<':
        return true
    }
    return false
}





~~~~~~~~~~~~~~~~~~~~
#####src\core\object.go#####package core

import "fmt"

type ValueType int

const (
    IntValue ValueType = 1 << iota
    FloatValue
    BooleanValue
    StringValue
    AnyValue
    ArrayValue
    ObjectValue
)

type Value struct {
    t ValueType
    int_value int
    float_value float64
    bool_value bool
    str_value string
    any_value interface{}
    arr_value []interface{}
    obj_value map[string]interface{}
}

func newVal(rawVal interface{}) Value {
    var val Value
    switch v := rawVal.(type) {
    case int:
        val = Value{t: IntValue, int_value: v}
    case float64:
        val = Value{t: FloatValue, float_value: v}
    case float32:
        val = Value{t: FloatValue, float_value: float64(v)}
    case bool:
        val = Value{t: BooleanValue, bool_value: v}
    case string:
        val = Value{t: StringValue, str_value: v}
    case []interface{}:
        val = Value{t: ArrayValue, arr_value: v}
    case map[string]interface{}:
        val = Value{t: ObjectValue, obj_value: v}
    default:
        panic(fmt.Sprintln("unknow exception when newVal:", rawVal))
    }
    return val
}

func (v *Value) val() interface{} {
    switch {
    case v.isIntValue(): return v.int_value
    case v.isFloatValue(): return v.float_value
    case v.isBooleanValue(): return v.bool_value
    case v.isStringValue(): return v.str_value
    case v.isArrayValue(): return v.arr_value
    case v.isObjectValue(): return v.obj_value
    case v.isAnyValue(): return v.any_value
    }
    return nil
}

func (v *Value) isIntValue() bool {
    return (v.t & IntValue) == IntValue
}

func (v *Value) isFloatValue() bool {
    return (v.t & FloatValue) == FloatValue
}

func (v *Value) isBooleanValue() bool {
    return (v.t & BooleanValue) == BooleanValue
}

func (v *Value) isStringValue() bool {
    return (v.t & StringValue) == StringValue
}

func (v *Value) isAnyValue() bool {
    return (v.t & AnyValue) == AnyValue
}

func (v *Value) isArrayValue() bool {
    return (v.t & ArrayValue) == ArrayValue
}

func (v *Value) isObjectValue() bool {
    return (v.t & ObjectValue) == ObjectValue
}

type StatementResultType int

const (
    StatementReturn StatementResultType = 1 << iota
    StatementContinue
    StatementBreak
    StatementNormal
)

type StatementResult struct {
    t StatementResultType
    val Value
}

func (this *StatementResult) isStatementReturn() bool {
    return (this.t & StatementReturn) == StatementReturn
}

func (this *StatementResult) isStatementContinue() bool {
    return (this.t & StatementContinue) == StatementContinue
}

func (this *StatementResult) isStatementBreak() bool {
    return (this.t & StatementBreak) == StatementBreak
}

func (this *StatementResult) isStatementNormal() bool {
    return (this.t & StatementNormal) == StatementNormal
}

type Variable struct{
    name string
    val Value
}

func newVar(name string, rawVal interface{}) *Variable {
    res := &Variable{
        name: name,
        val:  newVal(rawVal),
    }

    return res
}

func toVar(name string, rawVal Value) *Variable {
    res := &Variable{
        name: name,
        val:  rawVal,
    }
    return res
}


type Variables map[string]*Variable

func newVariables() Variables {
    return make(map[string]*Variable)
}

func (vs *Variables) isEmpty() bool {
    return vs == nil || len(*vs) < 1
}

func (vs *Variables) add(v *Variable) {
    (*vs)[v.name] = v
}

func (vs *Variables) get(name string) *Variable {
    if vs.isEmpty() {
        return nil
    }
    res, ok := (*vs)[name]
    if ok {
        return res
    }
    return nil
}

type VarScope struct {
    super *Variables
    local *Variables
}

func newVarScope(super, local *Variables) *VarScope {
    return &VarScope{
        super: super,
        local: local,
    }
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\object_test.go#####package core

import (
    "bufio"
    "bytes"
    "fmt"
    "os"
    "regexp"
    "strings"
    "testing"
)


func Test_clone(t *testing.T) {
    f, _ := os.Open("d:/raw.txt")
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if !strings.HasPrefix(line, "private") {
            continue
        }
        re := regexp.MustCompile("private\\s+\\w+\\s+(\\w+);")
        res := re.FindAllStringSubmatch(line, -1)
        fname := res[0][1]
        mt := strings.ToUpper(fname[:1]) + fname[1:]
        fmt.Printf("obj.set%v(this.%v);\n", mt, fname)
    }
}

func Test_fields(t *testing.T) {
    f, _ := os.Open("d:/raw.txt")
    scanner := bufio.NewScanner(f)
    var buf bytes.Buffer
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        re := regexp.MustCompile("`(\\w+)`")
        res := re.FindAllStringSubmatch(line, -1)
        buf.WriteString(res[0][1])
        buf.WriteString(", ")
    }
    fmt.Println(buf.String())
}

func Test_swi(t *testing.T) {
    a := 3
    a = a ^ 1
    a = a ^ 1
    switch a {
    case 3:
        fmt.Println("a == 3")
        if a > 0 {
            fmt.Println("a > 0")
            break
        }
        fmt.Println("a <= 0")

    }
}

func Test_obj(t *testing.T) {
    v1 := Value{
        t:           IntValue,
        int_value:   99,
        float_value: 0,
        bool_value:  false,
        str_value:   "",
        arr_value:   nil,
        obj_value:   nil,
    }
    v2 := v1
    v2.t = FloatValue
    v2.float_value = 3.14
    fmt.Println("v1:", v1)
    fmt.Println("v2:", v2)
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\statement.go#####package core

import (
    "bytes"
)

type StatementType int

const (
    ExpressionStatement StatementType = 1 << iota
    IfStatement
    ForStatement
    SwitchStatement
    ReturnStatement
)


type Statement struct {
    t StatementType
    tmpcount int
    exprs []*Expression
    preExpr *Expression
    condition *Expression
    postExpr *Expression
    block []*Statement
    raw []Token // token列表
    compiled bool
}


func (stmt *Statement) addStatement(stm *Statement) {
    stmt.block = append(stmt.block, stm)
}

func (stmt *Statement) stmts() []*Statement {
    return stmt.block
}

func (stmt *Statement) getRaw() []Token {
    return stmt.raw
}

func (stmt *Statement) setRaw(ts []Token) {
    stmt.raw = ts
}

func (stmt *Statement) isCompiled() bool {
    return stmt.compiled
}

func (stmt *Statement) setCompiled(flag bool) {
    stmt.compiled = flag
}


func (s *Statement) setHeaderInfo(exprs []*Expression) {
    s.preExpr = exprs[0]
    s.condition = exprs[1]
    s.postExpr = exprs[2]
}

func (s *Statement) addExpression(expr *Expression) {
    if len(s.exprs)>0 && s.exprs[len(s.exprs)-1].isMultiExpression() && !(s.exprs[len(s.exprs)-1].listFinish) {
        lastExpr := s.exprs[len(s.exprs)-1]
        subExprs := &lastExpr.list

        if expr.isMultiExpression() {
            expr = expr.list[0]
        }

        *subExprs = append(*subExprs, expr)

        if !expr.isTmpExpression() {
            lastExpr.listFinish = true
        }
        return
    }
    s.exprs = append(s.exprs, expr)
}

func (s *Statement) isExpressionStatement() bool {
    return (s.t & ExpressionStatement) == ExpressionStatement
}

func (s *Statement) isIfStatement() bool {
    return (s.t & IfStatement) == IfStatement
}

func (s *Statement) isForStatement() bool {
    return (s.t & ForStatement) == ForStatement
}

func (s *Statement) isSwitchStatement() bool {
    return (s.t & SwitchStatement) == SwitchStatement
}

func (s *Statement) isReturnStatement() bool {
    return (s.t & ReturnStatement) == ReturnStatement
}


func (s *Statement) String() string {
    var res bytes.Buffer
    if s.isReturnStatement() {
        res.WriteString(" return: ")
    }
    for _, t := range s.raw {
        res.WriteString(t.String())
        res.WriteString(" ")
    }
    if (s.t & IfStatement) == IfStatement {
        res.WriteString("condition:")
        res.WriteString(s.condition.String())
        res.WriteString(" ")
    }
    if (s.t & ForStatement) == ForStatement {
        res.WriteString("header:")
        res.WriteString(s.preExpr.String())
        res.WriteString("; ")
        res.WriteString(s.condition.String())
        res.WriteString("; ")
        res.WriteString(s.postExpr.String())
        res.WriteString(" ")
    }
    return res.String()
}

func newStatement(t StatementType, ts []Token) *Statement {
    return &Statement{
        t:     t,
        exprs: nil,
        raw:   ts,
    }
}

type StatementList interface {
    stmts() []*Statement
    addStatement(*Statement)
    getRaw() []Token
    setRaw([]Token)
    isCompiled() bool
    setCompiled(bool)
}

type Function struct {
    super Variables // 父作用域的变量列表
    local Variables // 当前作用域的变量列表
    params []Value // 参数
    res []Value // 返回值
    block []*Statement // 执行语句
    name string
    defToken Token
    raw []Token // token列表
    compiled bool
}

//func newFunc(name string)

func newFunc(name string) *Function {
    return &Function{local:newVariables(), name:name}
}

func (f *Function) addStatement(stm *Statement) {
    f.block = append(f.block, stm)
}

func (f *Function) stmts() []*Statement {
    return f.block
}

func (f *Function) getRaw() []Token {
    return f.raw
}

func (f *Function) setRaw(ts []Token) {
    f.raw = ts
}

func (f *Function) isCompiled() bool {
    return f.compiled
}

func (f *Function) setCompiled(flag bool) {
    f.compiled = flag
}




~~~~~~~~~~~~~~~~~~~~
#####src\core\util.go#####package core

import "fmt"

func match(src string, targets ...string) bool {
    for _, target := range targets {
        if src == target {
            return true
        }
    }
    return false
}

func exitOnError(err error, a ...string) {
    if err != nil {
        fmt.Println(a)
        panic(err)
    }
}

func insert(h Token, ts []Token) []Token {
    res := make([]Token, 0, len(ts)+1)
    res = append(res, h)
    for _, t := range ts {
        res = append(res, t)
    }
    return res
}

func insert2(t1, t2 Token, ts []Token) []Token {
    res := make([]Token, 0, len(ts)+2)
    res = append(res, t1)
    res = append(res, t2)
    for _, t := range ts {
        res = append(res, t)
    }
    return res
}
~~~~~~~~~~~~~~~~~~~~
#####src\qk\main.go#####package main

import "core"

func main()  {
    core.Run()
}


~~~~~~~~~~~~~~~~~~~~
#####src\qk\main_test.go#####package main

import (
    "bufio"
    "fmt"
    "os"
    "regexp"
    "strings"
    "testing"
)

func Test_compile(t *testing.T) {
    var res []interface{}
    res = append(res, 3)
    res = append(res, false)
    res = append(res, "test")
    fmt.Println(res)
    fmt.Println(res...)
    fmt.Println("successfully!")
}



func Test_fhandle2(t *testing.T) {
    tableName := "table_info"
    fmt.Printf("DROP TABLE IF EXISTS `%v`;\n", tableName)
    fmt.Printf("CREATE TABLE `%v` (\n", tableName)
    tfs := getTfs()
    //fmt.Println(len(infos), len(comments))
    for _, tf := range tfs {
        fmt.Printf("%v    COMMENT '%v', \n", tf.f, tf.c)
    }

}

type tf struct {
    f string
    c string
}

func getTfs() []tf {
    var res []tf
    f, _ := os.Open("d:/origin.txt")
    scanner := bufio.NewScanner(f)
    var comment string
    var field string
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if comment == "" && strings.HasPrefix(line, "*") {
            line = strings.TrimSpace(line[1:])
            comment = line
        }
        if comment != "" && field == "" && strings.HasPrefix(line, "private") {
            re := regexp.MustCompile(`\w+\s+(\w+);`)
            arr := re.FindAllStringSubmatch(line, -1)
            //fmt.Println("arr:", arr[0][1])
            field = arr[0][1]

            //handleInfo(field, comment)
            res = append(res, tf{field, comment})
            field = ""
            comment = ""
        }
    }
    return res
}

func Test_fhandle1(t *testing.T) {
    tableName := "table_info"
    fmt.Printf("DROP TABLE IF EXISTS `%v`;\n", tableName)
    fmt.Printf("CREATE TABLE `%v` (\n", tableName)
    infos := fieldInfos()
    comments := getComments()
    //fmt.Println(len(infos), len(comments))
    for i, info := range infos {
      fmt.Printf("%v COMMENT '%v', \n", info, comments[i])
    }

}

func getComments() []string {
    var res []string
    f, _ := os.Open("d:/origin.txt")
    scanner := bufio.NewScanner(f)
    var comment string
    var field string
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if comment == "" && strings.HasPrefix(line, "*") {
            line = strings.TrimSpace(line[1:])
            comment = line
        }
        if comment != "" && field == "" && strings.HasPrefix(line, "private") {
            re := regexp.MustCompile(`\w+\s+(\w+);`)
            arr := re.FindAllStringSubmatch(line, -1)
            //fmt.Println("arr:", arr[0][1])
            field = arr[0][1]

            //handleInfo(field, comment)
            res = append(res, comment)
            field = ""
            comment = ""
        }
    }
    return res
}

func handleInfo(field, comment string) {

    //msg := fmt.Sprintf("alter table %v modify column %v comment '%v';", tableName, field, comment)
    //fmt.Println(field, " - ", comment)
    //fmt.Println(msg)
}

func fieldInfos() []string {
    tableCreate := `
id int primary key auto_increment,
tableName varchar(100) not null,
tableTag varchar(150) not null,
taskId int,
primaryKey varchar(200),
lastUpdatedColumnName varchar(200),
schemaInfo text,
description varchar(2000),
ext varchar(200),
createdDate datetime,
createdBy varchar(150),
lastUpdatedDate datetime,
lastUpdatedBy varchar(150),
`
var res []string
scanner := bufio.NewScanner(strings.NewReader(tableCreate))
for scanner.Scan() {
    line := strings.TrimSpace(scanner.Text())
    if line == "" {
        continue
    }
    res = append(res, line[:len(line)-1])
}
return res
}

~~~~~~~~~~~~~~~~~~~~
#####start#####
export GOPATH=`pwd`

go install qk~~~~~~~~~~~~~~~~~~~~
