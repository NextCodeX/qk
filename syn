#####demo.qk#####println("hi, \"joker\" \n")

a = 1
b = 3
c = 7 + a * b
if b >= 0 {
    println("b 大于 0")
}
println("c:", c)

add(n1, n2) {
    res = n1 + n2
    return n3
}
d = add(13, 23)
println("add result:", d)

arr = [1, true, "testing"]
println("a len:", a.len)
println("a[1]", a[1])
arr.add("hello world")
println("a len:", a.len)

obj = {
name: "tome",
age: 18
}
println("user age:", obj.age)
println("user name:", obj["name"])


~~~~~~~~~~~~~~~~~~~~
#####expr.qk#####// 数组test
arr = [1,false,"tts"]
println("arr[1]:", arr[1])
arr[1] = "TaKI"
println("arr[1]:", arr[1])

// 对象测试
obj = {name:"changlie",age:18}
println("obj.name:", obj.name, ", obj.age:", obj.age)
obj.name = "tianyoushi"
obj.age = 14
println("obj.name:", obj.name, ", obj.age:", obj.age)

a = 2
a++
b = 3.5
b--
/**
multi
line
comment
测试
*/
println("b 大于等于 0:", b >= 0)

c = 3 + a * b
c += 2
println(a, b, c, a==b)~~~~~~~~~~~~~~~~~~~~
#####src\core\compile.go#####package core

import (
    "fmt"
    "strconv"
    "bytes"
	"encoding/json"
)

var (
    funcList = make(map[string]*Function)
    mainFunc = newFunc("main")
)

var tmpcount int


func Compile(stmts StatementList, ts []Token) {
    if stmts.isCompiled() {
        return
    }else {
        stmts.setCompiled(true)
    }
    extractStatement(stmts, ts)
    parseStatementList(stmts.stmts())

    for _, customFunc := range funcList {
       Compile(customFunc, customFunc.getRaw())
    }
}

func extractStatement(stmts StatementList, ts []Token) {
    stmts.setRaw(ts)
    for i := 0; i < len(ts); {
        t := ts[i]
        var endIndex int
        var stmt *Statement

        if !t.isIdentifier() && !t.isComplex() {
            goto next_loop
        }
        switch t.str {
        case "if":
            stmt, endIndex = parseIfStatement(i, ts)
        case "for":
            stmt, endIndex = parseForStatement(i, ts)
        case "switch":
        case "return":
            stmt, endIndex = parseReturnStatement(i, ts)
        default:
            if t.isFdef() {
                f, endIndex1 := parseFunction(i, ts)
                funcList[f.name] = f
                i = endIndex1
                goto next_loop
            }
            endIndex = nextBoundary(i, ts)
            if endIndex > 0 {
                stmt = newStatement(ExpressionStatement, ts[i:endIndex])
            }
        }
        if endIndex > 0 {
            stmts.addStatement(stmt)
            i = endIndex
        }

    next_loop:
        i++
    }
}

func parseReturnStatement(currentIndex int, ts []Token) (*Statement, int) {
    stmt := &Statement{t:ReturnStatement}
    size := len(ts)
    var endIndex int
    for i:=currentIndex+1; i<size; i++ {
        t := ts[i]
        if t.assertSymbols("}", ";") {
            endIndex = i
            break
        }

        stmt.raw = append(stmt.raw, t)

        if i==size-1 {
            endIndex = i
        }
    }
    return stmt, endIndex
}

func parseFunction(currentIndex int, ts []Token) (*Function, int) {
    var nextIndex int
    f := newFunc(ts[currentIndex].str)
    f.defToken = ts[currentIndex]
    var blockTokens []Token
    size := len(ts)
    scopeOpenCount := 1
    for i:=currentIndex+2; i<size; i++ {
        token := ts[i]
        if token.assertSymbol("{") {
            scopeOpenCount ++
        }
        if token.assertSymbol("}") {
            scopeOpenCount --
            if scopeOpenCount == 0 {
                nextIndex = i
                break
            }
        }
        blockTokens = append(blockTokens, token)
    }
    if scopeOpenCount > 0 {
        panic("parse function statement exception!")
    }
    f.setRaw(blockTokens)
    return f, nextIndex
}

func parseIfStatement(currentIndex int, ts []Token) (*Statement, int) {
    stmt := &Statement{t:IfStatement}

    index := nextSymbol(currentIndex, ts, "{")
    stmt.condition = &Expression{
        t:     BinaryExpression,
        raw:   ts[currentIndex+1:index],
    }

    scopeOpenCount := 1
    var endIndex int
    for i:=index+1; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol("{") {
            scopeOpenCount++
        }
        if t.assertSymbol("}") {
            scopeOpenCount--
            if scopeOpenCount == 0 {
                endIndex = i
                break
            }
        }
        stmt.raw = append(stmt.raw, t)
    }
    return stmt, endIndex
}

func parseForStatement(currentIndex int, ts []Token) (*Statement, int) {
    stmt := &Statement{t:IfStatement}
    index := nextSymbol(currentIndex, ts, "{")
    exprs := splitExpression(ts[currentIndex+1:index])
    stmt.setHeaderInfo(exprs)
    scopeOpenCount := 1
    var endIndex int
    for i:=index+1; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol("{") {
            scopeOpenCount++
        }
        if t.assertSymbol("}") {
            scopeOpenCount--
            if scopeOpenCount == 0 {
                endIndex = i
                break
            }
        }
        stmt.raw = append(stmt.raw, t)
    }
    return stmt, endIndex
}

func splitExpression(ts []Token) []*Expression {
    res := make([]*Expression, 3)
    size := len(ts)
    // for语句没用";"分隔，表达式即为condition expression
    if !hasSymbol(ts, ";") {
        res[1] = &Expression{
            t:     BinaryExpression,
            raw:   ts,
        }
        return res
    }

    //for 语句存在";"分隔符时
    // extract initialize expression
    index := nextSymbol(0, ts, ";")
    if index > 2 {
        res[0] = &Expression{
            t:     BinaryExpression,
            raw:   ts[:index],
        }
    }

    // extract condition expression
    preIndex := index+1
    index = nextSymbol(preIndex, ts, ";")
    if index - preIndex > 2 {
        res[1] = &Expression{
            t:     BinaryExpression,
            raw:   ts[preIndex:index],
        }
    } else if preIndex<size && !hasSymbol(ts[preIndex:], ";") {
        res[1] = &Expression{
            t:     BinaryExpression,
            raw:   ts[preIndex:],
        }
        index = size
    }

    // extract post expression
    preIndex = index+1
    if preIndex < size {
        res[2] = &Expression{
            t:     BinaryExpression,
            raw:   ts[preIndex:],
        }
    }
    return res
}


func nextBoundary(currentIndex int, ts []Token) int {
    return nextSymbol(currentIndex, ts, ";")
}

func nextSymbol(currentIndex int, ts []Token, s string) int {
    for i:=currentIndex; i<len(ts); i++ {
        t := ts[i]
        if t.assertSymbol(s) {
            return i
        }
    }
    return -1
}

func hasSymbol(ts []Token, ss ...string) bool {
    for i:=0; i<len(ts); i++ {
        t := ts[i]
        for _, s := range ss {
			if t.assertSymbol(s) {
				return true
			}
		}
    }
    return false
}


func parseStatementList(stmts []*Statement) {
    for _, stmt := range stmts {
        parseStatement(stmt)
    }
}

func parseStatement(stmt *Statement) {
    ts := stmt.raw
    switch {
    case stmt.isExpressionStatement():
        expr := parseExpressionStatement(ts)
        stmt.addExpression(expr)

    case stmt.isIfStatement():
    case stmt.isForStatement():
    case stmt.isSwitchStatement():
    case stmt.isReturnStatement():
    }
}

func parseExpressionStatement(ts []Token) *Expression {
    var expr *Expression

    // 去括号
	ts = clearParentheses(ts)

	tlen := len(ts)

	if tlen % 2 == 0 {
		runtimeExcption("error expression:", tokensString(ts))
	}

	if tlen < 1 {
		return expr
	}
	switch {
	case tlen == 1:
		return parseUnaryExpression(ts)
	//case tlen == 2:
	//	if !ts[0].isIdentifier() {
	//		return expr
	//	}
	//	parseUnaryPlusExpression(ts)

	case tlen == 3:
		expr = parseBinaryExpression(ts)

	//case tlen == 5:
	//	expr = parseTernaryExpression(ts)
	default:
		// 处理多维表达式
		expr = parseMultivariateExpression(ts)
	}
	if expr == nil {
		runtimeExcption("parseExpressionStatement Exception:", tokensString(ts))
	}
	expr.raw = ts
	return expr
}

// 消除括号
func clearParentheses(ts []Token) []Token {
	tlen := len(ts)
	if tlen >= 3 && ts[0].assertSymbol("(") && ts[tlen-1].assertSymbol(")") {
		ts = ts[1 : tlen-1]
	}
	return ts
}

//func parseTernaryExpression(ts []Token) (expr *Expression) {
//    if !ts[0].isIdentifier() || !ts[1].assertSymbol("=") {
//        return
//    }
//    expr = parseBinaryExpression(ts[2:])
//    expr.tmpname = ts[0].str
//    expr.t = expr.t | TmpExpression
//    return expr
//}

//func parseUnaryPlusExpression(ts []Token) {
//    if ts[1].assertSymbol("++") {
//
//    }else if ts[2].assertSymbol("--") {
//
//    }
//}

// 获取一元表达式
func parseUnaryExpression(ts []Token) *Expression {
	token := ts[0]

	// 处理自增, 自减
	if token.isAddSelf() || token.isSubSelf() {
		op := symbolToken("+")
		if token.isSubSelf() {
			op = symbolToken("-")
		}
		var tmpTokens []Token
		tmpTokens = append(tmpTokens, token)
		tmpTokens = append(tmpTokens, op)
		tmpTokens = append(tmpTokens, newToken("1", Int))
		tmpTokens = append(tmpTokens, token)
		return generateBinaryExpr(tmpTokens)
	}

    expr := &Expression{}
    primaryExpr := parsePrimaryExpression(&token)
    expr.left = primaryExpr
    if token.isStr() {
        expr.t = StringExpression | ConstExpression
        return expr
    }
    if token.isInt() {
        expr.t = IntExpression | ConstExpression
        return expr
    }
    if token.isFloat() {
        expr.t = FloatExpression | ConstExpression
        return expr
    }
    if token.isIdentifier() {
        if primaryExpr.isVar() {
            expr.t = VarExpression
        } else {
            expr.t = BooleanExpression | ConstExpression
        }
        return expr
    }
    if token.isElement() {
		expr.t = ElementExpression
		return expr
	}
	if token.isAttribute() {
		expr.t = AttributeExpression
		return expr
	}
    if token.isFcall() {
        expr.t = FunctionCallExpression
        return expr
    }

    return nil
}

func parseMultivariateExpression(ts []Token) (expr *Expression) {
    var resVarToken *Token
    var multiExprTokens []Token
    if ts[1].assertSymbol("=") {
       resVarToken = &(ts[0])
       multiExprTokens = ts[2:]
    } else {
       multiExprTokens = ts
    }
    var exprTokensList [][]Token
    reduceTokensForExpression(resVarToken, multiExprTokens, &exprTokensList)
    //printExprTokens(exprTokensList)

	exprs := generateBinaryExprs(exprTokensList)
	finalExpr := getFinalExpr(exprs, resVarToken)

    expr = &Expression{
       t:MultiExpression,
       list:exprs,
       finalExpr:finalExpr,
    }
    return expr
}

func getFinalExpr(exprs []*Expression, resVarToken *Token) *Expression {
	var finalExprTokens *Expression
	isAssignExpr := resVarToken != nil
	for _, expr := range exprs {
		if isAssignExpr && expr.tmpname == resVarToken.str {
			finalExprTokens = expr
			break
		}
		if !isAssignExpr && expr.tmpname == "" {
			finalExprTokens = expr
			break
		}
	}
	if finalExprTokens == nil {
		runtimeExcption("failed to getFinalExpr resortExprTokensList")
	}
	return finalExprTokens
}

func generateBinaryExprs(exprTokensList [][]Token) []*Expression {
	var res []*Expression
	for _, tokens := range exprTokensList {
		expr := generateBinaryExpr(tokens)
		res = append(res, expr)
	}
	return res
}

func generateBinaryExpr(ts []Token) *Expression {
	size := len(ts)
	if size < 3 || size > 4 {
		runtimeExcption("generateBinaryExpr error args:", tokensString(ts))
		return nil
	}
	var expr *Expression
	if size == 4 {
		expr = parseBinaryExpression(ts[:3])
		expr.setTmpname(ts[3].str)
	} else {
		expr = parseBinaryExpression(ts)
	}
	return expr
}

// 分解多元表达式, 并把结果保存至exprTokensList *[][]Token
func reduceTokensForExpression(res *Token, ts []Token, exprTokensList *[][]Token) {
	var exprTokens []Token

	ts = clearParentheses(ts)

	size := len(ts)
	if size < 3 {
		runtimeExcption("reduceTokensForExpression Exception:", tokensString(ts))
	}

	// 处理括号是第一个token的情况
	if ts[0].assertSymbol("(") {
		leftTokens, nextIndex := extractTokensByParentheses(ts)
		tmpvarToken := getTmpVarToken()
		if !hasSymbol(leftTokens, "(") && len(leftTokens) == 3 {
			// 左处理
			exprTokens = append(leftTokens, tmpvarToken)
			*exprTokensList = append(*exprTokensList, exprTokens)

			// 右处理
			nextTokens := insert(tmpvarToken, ts[nextIndex:])
			reduceTokensForExpression(res, nextTokens, exprTokensList)
			return
		} else {
			// 左处理
			reduceTokensForExpression(&tmpvarToken, leftTokens, exprTokensList)

			// 右处理
			nextTokens := insert(tmpvarToken, ts[nextIndex:])
			reduceTokensForExpression(res, nextTokens, exprTokensList)
			return
		}
	}

	for i:=0; i<size; i++ {
		tmpSize := len(exprTokens)
		token := ts[i]

		condBoundry := tmpSize == 2
		condFinish := condBoundry && i==size-1
		preCond1 := condBoundry && i<size-1
		//if preCond1 {
		//	fmt.Printf("pre.priority:  %v:%v; next.priority: %v:%v \n", last(exprTokens).str, last(exprTokens).priority(), next(ts, i).str, next(ts, i).priority() )
		//}
		// 处理根据运算符优先级, 左向归约的情况
		condShiftLeft1 := preCond1 && last(exprTokens).equal(next(ts,i))
		condShiftLeft2 := preCond1 && last(exprTokens).lower(next(ts,i))
		//fmt.Printf("condFinish: %v, preCond1: %v, condShiftLeft1: %v, condShiftLeft2: %v\n", condFinish, preCond1, condShiftLeft1, condShiftLeft2)
		if condShiftLeft1 || condShiftLeft2 || condFinish {
			exprTokens = append(exprTokens, token)
			if !condFinish {
				tmpVarToken := getTmpVarToken()
				nextTokens := insert(tmpVarToken, ts[i+1:])
				exprTokens = append(exprTokens, tmpVarToken)
				reduceTokensForExpression(res, nextTokens, exprTokensList)
			}
			break
		}


		// 处理括号不是第一个token的情况
		condRightParentheses := preCond1 && token.assertSymbol("(")
		//fmt.Printf("condRightParentheses: %v; \n", condRightParentheses)
		if condRightParentheses {
			rightTokens, nextIndex := extractTokensByParentheses(ts[i:])
			nextIndex  = i+nextIndex // 转换回切片ts的相应索引
			if nextIndex < size - 1 {
				// 因为括号圈的不是右边整个表达式, 故先求括号值, 再通过运算符优先级求值
				tmpVarToken1 := getTmpVarToken() // 括号内的中间临时值
				reduceTokensForExpression(&tmpVarToken1, rightTokens, exprTokensList)

				// 根据运算符优先级的不同, tmpVarToken2可能是左边表达式的或者右边表达式的中间临时值
				tmpVarToken2 := getTmpVarToken()

				nextToken := ts[nextIndex]
				if last(exprTokens).equal(&nextToken) || last(exprTokens).lower(&nextToken) {
					// 左优先
					exprTokens = append(exprTokens, tmpVarToken1) // interval tmp result
					exprTokens = append(exprTokens, tmpVarToken2) // left expr result.

					nextTokens2 := insert(tmpVarToken2, ts[nextIndex:]) //
					reduceTokensForExpression(res, nextTokens2, exprTokensList)
				}else {
					// 右优先
					exprTokens = append(exprTokens, tmpVarToken2) // rigtht expr result.


					nextTokens3 := insert(tmpVarToken1, ts[nextIndex:])
					reduceTokensForExpression(&tmpVarToken2, nextTokens3, exprTokensList)
				}
				break
			}

			// 因为括号圈的是右边整个表达式时
			tmpVarToken3 := getTmpVarToken()
			exprTokens = append(exprTokens, tmpVarToken3)

			nextTokens := ts[i:]
			reduceTokensForExpression(&tmpVarToken3, nextTokens, exprTokensList)
			break
		}

		// 处理根据运算符优先级, 右向归约的情况
		condShiftRight1 := preCond1 && last(exprTokens).upper(next(ts,i))
		//fmt.Printf("condShiftRight1: %v; \n", condShiftRight1)
		if  condShiftRight1 {
			tmpVarToken := getTmpVarToken()
			nextTokens := ts[i:]
			exprTokens = append(exprTokens, tmpVarToken)
			reduceTokensForExpression(&tmpVarToken, nextTokens, exprTokensList)
			break
		}

		exprTokens = append(exprTokens, token)
	}

	if res != nil && len(exprTokens) == 3 {
		exprTokens = append(exprTokens, *res)
	}

	*exprTokensList = append(*exprTokensList, exprTokens)
}

// 获取括号内的表达式token列表
func extractTokensByParentheses(ts []Token) (res []Token, nextIndex int) {
	scopeOpen := 0
	for i, token := range ts {
		if token.assertSymbol("(") {
			scopeOpen ++
		}
		if token.assertSymbol(")") {
			scopeOpen --
			if scopeOpen == 0 {
				res = ts[1:i]
				nextIndex = i+1
				break
			}
		}
	}
	if scopeOpen != 0 {
		runtimeExcption("extractTokensByParentheses Exception:", tokensString(ts))
	}
	return res, nextIndex
}



func printExprTokens(exprTokensList [][]Token) {
    var buf bytes.Buffer
    for _, ts := range exprTokensList {
		buf.WriteString(tokensString(ts))
		buf.WriteString("\n")
	}
	fmt.Println(buf.String())
}

func last(ts []Token) *Token {
    return &ts[len(ts)-1]
}

func next(ts []Token, i int) *Token {
    return &ts[i+1]
}

func getTmpVarToken() Token {
	tmpname := getTmpname()
	return varToken(tmpname)
}

func getTmpname() string {
    name := fmt.Sprintf("tmp.%v", tmpcount)
    tmpcount++
    return name
}

// 根据token列表获取二元表达式
func parseBinaryExpression(ts []Token) *Expression {
    first := ts[0]
    mid := ts[1]
    third := ts[2]
    left := parsePrimaryExpression(&first)
    right := parsePrimaryExpression(&third)
    var op OperationType
    switch {

    case mid.assertSymbol("+"):
        op = Opadd
    case mid.assertSymbol("-"):
        op = Opsub
    case mid.assertSymbol("*"):
        op = Opmul
    case mid.assertSymbol("/"):
        op = Opdiv
	case mid.assertSymbol("%"):
		op = Opmod

	case mid.assertSymbol(">"):
		op = Opgt
	case mid.assertSymbol(">="):
		op = Opge
	case mid.assertSymbol("<"):
		op = Oplt
	case mid.assertSymbol("<="):
		op = Ople
	case mid.assertSymbol("=="):
		op = Opeq

	case  mid.assertSymbol("="):
		op = Opassign
	case mid.assertSymbol("+="):
		op = OpassignAfterAdd
	case mid.assertSymbol("-="):
		op = OpassignAfterSub
	case mid.assertSymbol("*="):
		op = OpassignAfterMul
	case mid.assertSymbol("/="):
		op = OpassignAfterDiv
	case mid.assertSymbol("%="):
		op = OpassignAfterMod

    default:
       runtimeExcption("parseBinaryExpression Exception:", tokensString(ts))
    }

    expr := &Expression{
        t:     BinaryExpression,
        op:    op,
        left:  left,
        right: right,
    }
    return expr
}


func parsePrimaryExpression(t *Token) *PrimaryExpr {
    v := tokenToValue(t)
    var res *PrimaryExpr
    if v != nil {
        res = &PrimaryExpr{res:v, t:ConstPrimaryExpressionType}

    } else if t.isElement() {
		exprs := getArgsFromToken(t.ts)
		res = &PrimaryExpr{name:t.str, args: exprs, t:ElementPrimaryExpressionType}

	} else if t.isAttribute() {
		res = &PrimaryExpr{name:t.str, caller:t.caller, t:AttibutePrimaryExpressionType}

	} else if t.isFcall() {
        exprs := getArgsFromToken(t.ts)
        res = &PrimaryExpr{name:t.str, args: exprs, t:OtherPrimaryExpressionType}

    } else {
        res = &PrimaryExpr{name:t.str, t:VarPrimaryExpressionType}
    }
    return res
}

func getArgsFromToken(ts []Token) []*Expression {
    var res []*Expression
    size := len(ts)
    if size < 1 {
        return res
    }
    if size == 1 || !hasSymbol(ts, ",") {
    	ts = parse4ComplexTokens(ts)
        expr := parseExpressionStatement(ts)
        assert(expr==nil, "failed to parse Expression:", tokensString(ts))
        res = append(res, expr)
        return res
    }
    var exprTokens []Token
    var nextIndex int
    for nextIndex >= 0 {
        exprTokens, nextIndex = extractExpressionByComma(nextIndex, ts)
		exprTokens = parse4ComplexTokens(exprTokens)
        expr := parseExpressionStatement(exprTokens)
        assert(expr==nil, "failed to parse Expression:", tokensString(ts))
        res = append(res, expr)
    }
    return res
}

func extractExpressionByComma(currentIndex int, ts []Token) (exprTokens []Token, nextIndex int) {
    size := len(ts)
    for i:=currentIndex; i<size; i++ {
        token := ts[i]
        if token.assertSymbol(",") {
            nextIndex = i+1
            break
        }
        exprTokens = append(exprTokens, token)
        if i == size - 1 {
            nextIndex = -1
        }
    }
    return exprTokens, nextIndex
}

func tokenToValue(t *Token) (v *Value) {
	if t.isArrLiteral() || t.isObjLiteral() {
		jsonstr := t.toJSONString()
		var v interface{}
		err := json.Unmarshal([]byte(jsonstr), &v)
		if err != nil {
			runtimeExcption("failed to generate object:", t.String())
		}
		return newVal(v)
	}
    if t.isFloat() {
        f, err := strconv.ParseFloat(t.str, 64)
        assert(err!=nil, t.String(), "line:", t.lineIndex)
        v = newVal(f)
        return
    }
    if t.isInt() {
        i, err := strconv.Atoi(t.str)
        assert(err!=nil, t.String(), "line:", t.lineIndex)
        v = newVal(i)
        return
    }
    if t.isStr() {
        v = newVal(fmt.Sprintf("%v", t.str))
        return
    }
    if t.isIdentifier() && (t.str == "true" || t.str == "false") {
        b, err := strconv.ParseBool(t.str)
        assert(err!=nil, t.String(), "line:", t.lineIndex)
        v = newVal(b)
        return
    }
    return nil
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\expression.go#####package core

import (
    "bytes"
    "strings"
	"fmt"
)

type ExpressionType int

const (
    IntExpression ExpressionType = 1 << iota
    FloatExpression
    BooleanExpression
    StringExpression
    ConstExpression
    VarExpression
    AttributeExpression
    ElementExpression
    FunctionCallExpression
    MethodCallExpression
    BinaryExpression
    MultiExpression
    TmpExpression
)

type OperationType int
const (

    // 逻辑运算
    Opeq OperationType = 1 << iota //等于 equal to
    Opgt // 大于 greater than
    Oplt // 小于 less than
    Opge // 大于等于 greater than or equal to
    Ople // 小于等于 less than or equal to

    Opor // 逻辑或
    Opand // 逻辑与

    // 算术运算
    Opadd // 相加
    Opsub // 相减
    Opmul // 相乘
    Opdiv // 相除
    Opmod // 求余(余数 remainder/残余数 modulo)

    // 赋值运算
    Opassign // 赋值
    OpassignAfterAdd // 相加后赋值
    OpassignAfterSub // 相减后赋值
    OpassignAfterMul // 相乘后赋值
    OpassignAfterDiv // 相除后赋值
    OpassignAfterMod // 求余后赋值

)

type Expression struct {
    vars *VarScope
    t ExpressionType
    op OperationType
    left *PrimaryExpr
    right *PrimaryExpr
    list []*Expression
    finalExpr *Expression
    listFinish bool
    raw []Token
    res *Value
    tmpname string
}

func (this *Expression) isAssign() bool {
    return (this.op & Opassign) == Opassign
}
func (this *Expression) isAssignAfterAdd() bool {
    return (this.op & OpassignAfterAdd) == OpassignAfterAdd
}
func (this *Expression) isAssignAfterSub() bool {
    return (this.op & OpassignAfterSub) ==OpassignAfterSub
}
func (this *Expression) isAssignAfterMul() bool {
    return (this.op & OpassignAfterMul) ==OpassignAfterMul
}
func (this *Expression) isAssignAfterDiv() bool {
    return (this.op & OpassignAfterDiv) ==OpassignAfterDiv
}
func (this *Expression) isAssignAfterMod() bool {
    return (this.op & OpassignAfterMod) ==OpassignAfterMod
}



func (this *Expression) isEq() bool {
    return (this.op & Opeq) ==Opeq
}
func (this *Expression) isGt() bool {
    return (this.op & Opgt) ==Opgt
}
func (this *Expression) isLt() bool {
    return (this.op & Oplt) ==Oplt
}
func (this *Expression) isGe() bool {
    return (this.op & Opge) ==Opge
}
func (this *Expression) isLe() bool {
    return (this.op & Ople) ==Ople
}

func (this *Expression) isOr() bool {
    return (this.op & Opor) ==Opor
}
func (this *Expression) isAnd() bool {
    return (this.op & Opand) ==Opand
}



func (this *Expression) isAdd() bool {
    return (this.op & Opadd) == Opadd
}

func (this *Expression) isSub() bool {
    return (this.op & Opsub) == Opsub
}

func (this *Expression) isMul() bool {
    return (this.op & Opmul) == Opmul
}

func (this *Expression) isDiv() bool {
    return (this.op & Opdiv) == Opdiv
}
func (this *Expression) isMod() bool {
    return (this.op & Opmod) ==Opmod
}

func newMultiExpression() *Expression {
    return &Expression{
        t:          MultiExpression,
        listFinish: false,
    }
}

func (this *Expression) isIntExpression() bool {
    return (this.t & IntExpression) == IntExpression
}

func (this *Expression) isFloatExpression() bool {
    return (this.t & FloatExpression) == FloatExpression
}

func (this *Expression) isBooleanExpression() bool {
    return (this.t & BooleanExpression) == BooleanExpression
}

func (this *Expression) isStringExpression() bool {
    return (this.t & StringExpression) == StringExpression
}

func (this *Expression) isConstExpression() bool {
    return (this.t & ConstExpression) == ConstExpression
}

func (this *Expression) isVarExpression() bool {
    return (this.t & VarExpression) == VarExpression
}

func (this *Expression) isAttributeExpression() bool {
	return (this.t & AttributeExpression) == AttributeExpression
}

func (this *Expression) isElementExpression() bool {
	return (this.t & ElementExpression) == ElementExpression
}

func (this *Expression) isFunctionCallExpression() bool {
    return (this.t & FunctionCallExpression) == FunctionCallExpression
}

func (this *Expression) isMethodCallExpression() bool {
    return (this.t & MethodCallExpression) == MethodCallExpression
}

func (this *Expression) isBinaryExpression() bool {
    return (this.t & BinaryExpression) == BinaryExpression
}

func (this *Expression) isMultiExpression() bool {
    return (this.t & MultiExpression) == MultiExpression
}

func (this *Expression) isTmpExpression() bool {
    return (this.t & TmpExpression) == TmpExpression
}

func (expr *Expression) searchVariable(name string) *Variable {
    res := expr.vars.local.get(name)
    if res != nil {
        return res
    }
    if expr.vars.super == nil {
		//runtimeExcption("variable", name, "is undefined")
        return nil
    }
    res = expr.vars.super.get(name)
    if res != nil {
        return res
    }
	//runtimeExcption("variable", name, "is undefined")
    return nil
}

func (expr *Expression) searchArrayVariable(varname string) []interface{} {
	varObj := expr.searchVariable(varname)
	varVal := varObj.val.val()

	var ok bool
	arrVal, ok := varVal.([]interface{})
	if !ok {
		varValType := fmt.Sprintf("%T", varVal)
		runtimeExcption("error operator: ", varname, "is not a array", varValType, varVal)
		return nil
	}
	return arrVal
}

func (expr *Expression) addVariable(vr *Variable)  {
    expr.vars.local.add(vr)
}

func (expr *Expression) addVar(name string, val *Value)  {
    variable := toVar(name,  val)
    expr.vars.local.add(variable)
}

func (expr *Expression) leftVal() *Value {
    return evalPrimaryExpr(expr.left, expr)
}

func (expr *Expression) rightVal() *Value {
    return evalPrimaryExpr(expr.right, expr)
}

func evalPrimaryExpr(primaryExpr *PrimaryExpr, expr *Expression) *Value {
	if primaryExpr == nil {
		return NULL
	}
	if primaryExpr.isConst() {
		return primaryExpr.res
	}
	if primaryExpr.isVar() {
		varname := primaryExpr.name
		variable := expr.searchVariable(varname)
		if variable == nil {
			return NULL
		}
		return variable.val
	}
	if primaryExpr.isElement() {
		return executeElementExpression(expr)
	}
	if primaryExpr.isAttibute() {
		return executeAttributeExpression(expr)
	}
	return NULL
}

func (expr *Expression) setTmpname(name string) {
    expr.t = expr.t | TmpExpression
    expr.tmpname = name
}


func (expr *Expression) TypeString() string {
    if expr == nil {
        return ""
    }
    var res bytes.Buffer
    if expr.isIntExpression() {
        res.WriteString("int expression, ")
    }
    if expr.isBooleanExpression() {
        res.WriteString("bool expression, ")
    }
    if expr.isStringExpression() {
        res.WriteString("string expression, ")
    }
    if expr.isConstExpression() {
        res.WriteString("const expression, ")
    }
    if expr.isVarExpression() {
        res.WriteString("var expression, ")
    }
	if expr.isAttributeExpression() {
		res.WriteString("attribute expression, ")
	}
	if expr.isElementExpression() {
		res.WriteString("element expression, ")
	}

    if expr.isFunctionCallExpression() {
        res.WriteString("function call expression, ")
    }
    if expr.isMethodCallExpression() {
        res.WriteString("method call expression, ")
    }
    if expr.isBinaryExpression() {
        res.WriteString("binary expression, ")
    }
    if expr.isMultiExpression() {
        res.WriteString("multi expression, ")
    }
    if expr.isTmpExpression() {
        res.WriteString("tmp expression, ")
    }
    return strings.Trim(strings.TrimSpace(res.String()), ",")
}

func (expr *Expression) String() string {
    if expr == nil {
        return ""
    }
    var res bytes.Buffer
    for _, t := range expr.raw {
        res.WriteString(t.String())
        res.WriteString(" ")
    }
    return res.String()
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\function.go#####package core


type Function struct {
	super Variables // 父作用域的变量列表
	local Variables // 当前作用域的变量列表
	params []Value // 参数
	res []Value // 返回值
	block []*Statement // 执行语句
	name string
	defToken Token
	raw []Token // token列表
	compiled bool
}

//func newFunc(name string)

func newFunc(name string) *Function {
	return &Function{local:newVariables(), name:name}
}

func (f *Function) addStatement(stm *Statement) {
	f.block = append(f.block, stm)
}

func (f *Function) stmts() []*Statement {
	return f.block
}

func (f *Function) getRaw() []Token {
	return f.raw
}

func (f *Function) setRaw(ts []Token) {
	f.raw = ts
}

func (f *Function) isCompiled() bool {
	return f.compiled
}

func (f *Function) setCompiled(flag bool) {
	f.compiled = flag
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\index.go#####package core

import (
    "fmt"
    "io/ioutil"
    "os/exec"
    "runtime"
    "strings"
)

const DEBUG_MODE = true

func Run() {
    //qkfile := "demo.qk"
    qkfile := "expr.qk"
    bs, _ := ioutil.ReadFile(qkfile)
    ts := ParseTokens(bs)
    printTokensByLine(ts)
    Compile(mainFunc, ts)
    printFunc()
    fmt.Println("================")
    Interpret()
}

func printFunc() {
    doPrintFunc(mainFunc)
    for _, fn := range funcList {
        doPrintFunc(fn)
    }
}

func doPrintFunc(fn *Function) {
    fmt.Println("######################", fn.name, len(fn.block))
    for i, stmt := range fn.block {
        fmt.Printf("num: %v line %v: \n %v \n", len(stmt.raw), i, stmt)
    }
}

func printTokensByLine(tokens []Token) {
    for i, token := range tokens {
        fmt.Printf("count %v-line:%v: [%v] -> %v \n", i, token.lineIndex, token.String(), token.TokenTypeName())
    }
}

// 获取命令所在的路径
func getCmdDir() string {
    cmd := exec.Command( "cmd", "/c", "cd")
    if runtime.GOOS != "windows" {
        cmd = exec.Command("pwd")
    }
    d, err := cmd.CombinedOutput()
    assert(err!=nil, err, "failed to get personal work directory")
    pwd := strings.TrimSpace(string(d))
    return pwd
}


~~~~~~~~~~~~~~~~~~~~
#####src\core\interpreter.go#####package core

import "fmt"


func Interpret() {
    local := newVariables()
    executeStatementList(local)
}

func executeStatementList(local Variables) {
    for _, stmt := range mainFunc.block {
        executeStatement(stmt, newVarScope(nil, &local))
    }
}

func executeStatement(stmt *Statement, vars *VarScope) *StatementResultType {
    if stmt.isExpressionStatement() {
        for _, expr := range stmt.exprs {
            expr.vars = vars
            executeExpression(expr)
        }
    }

    return nil
}

func executeExpression(expr *Expression) (res *Value) {
    if expr.isConstExpression() || expr.isVarExpression() || expr.isElementExpression() || expr.isAttributeExpression() {
        return expr.leftVal()
    }

    if expr.isBinaryExpression() {
        return executeBinaryExpression(expr)
    }
    if expr.isFunctionCallExpression() {
        return executeFunctionCallExpression(expr)
    }
    if expr.isMultiExpression() {
    	return executeMultiExpression(expr)
	}

    return
}

func executeAttributeExpression(expr *Expression) (res *Value) {
	varname := expr.left.caller
	attrname := expr.left.name
	varVal := expr.searchVariable(varname)
	if varVal == nil {
		return NULL
	}
	varRawVal := varVal.val.val()
	obj, ok := varRawVal.(map[string]interface{})
	if !ok {
		return NULL
	}
	return newVal(obj[attrname])
}

func executeElementExpression(expr *Expression) (res *Value) {
	varname := expr.left.name
	arrRawVal := expr.searchArrayVariable(varname)

	argVals := toGoTypeValues(expr.left.args, expr.vars)
	argRawVals := getArrayIndexs(len(arrRawVal), argVals)
	return newVal(arrRawVal[argRawVals[0]])
}


func executeMultiExpression(expr *Expression) (res *Value) {
	finalExpr := expr.finalExpr
	finalExpr.vars = expr.vars

	return delayCalculate(finalExpr, expr.list)
}

func delayCalculate(expr *Expression, exprList []*Expression) *Value {
	left := expr.left
	right := expr.right
	if left.isConst() && right.isConst() {
		return executeBinaryExpression(expr)
	}

	checkValueExist(left, expr, exprList)
	checkValueExist(right, expr, exprList)

	return executeBinaryExpression(expr)
}

func checkValueExist(primaryExpr *PrimaryExpr, expr *Expression, exprList []*Expression) {
	if primaryExpr.isVar() {
		variable := expr.searchVariable(primaryExpr.name)
		if variable == nil {
			subExpr := getSubExprForMultiExpression(primaryExpr.name, exprList)
			if subExpr == nil {
				runtimeExcption("executeMultiExpression Exception")
			}
			subExpr.vars = expr.vars
			executeBinaryExpression(subExpr)
		}
	}
}

func getSubExprForMultiExpression(varname string, exprList []*Expression) *Expression {
	for _, subExpr := range exprList {
		if subExpr.tmpname == varname {
			return subExpr
		}
	}
	return nil
}

func executeFunctionCallExpression(expr *Expression) (res *Value) {
	//fmt.Println("executeFunctionCallExpression", tokensString(expr.raw))
    functionName := expr.left.name
    args := expr.left.args
    if functionName == "println" {
        argVals := toGoTypeValues(args, expr.vars)
        if len(argVals) < 1 {
            fmt.Println()
        }else{
            fmt.Println(argVals...)
        }
    }
    return nil
}

func executeBinaryExpression(expr *Expression) (res *Value) {
	if expr.res != nil && expr.left.isConst() && expr.right.isConst() {
		return expr.res
	}

    switch {
    case expr.isAssign():
        res = evalAssignBinaryExpression(expr)
	case expr.isAssignAfterAdd():
		res = evalAssignAfterAddBinaryExpression(expr)
	case expr.isAssignAfterSub():
		res = evalAssignAfterSubBinaryExpression(expr)
	case expr.isAssignAfterMul():
		res = evalAssignAfterMulBinaryExpression(expr)
	case expr.isAssignAfterDiv():
		res = evalAssignAfterDivBinaryExpression(expr)
	case expr.isAssignAfterMod():
		res = evalAssignAfterModBinaryExpression(expr)

    case expr.isAdd():
        res = evalAddBinaryExpression(expr)
	case expr.isSub():
		res = evalSubBinaryExpression(expr)
	case expr.isMul():
		res = evalMulBinaryExpression(expr)
	case expr.isDiv():
		res = evalDivBinaryExpression(expr)
	case expr.isMod():
		res = evalModBinaryExpression(expr)

	case expr.isEq():
		res = evalEqBinaryExpression(expr)
	case expr.isGt():
		res = evalGtBinaryExpression(expr)
	case expr.isGe():
		res = evalGeBinaryExpression(expr)
	case expr.isLt():
		res = evalLtBinaryExpression(expr)
	case expr.isLe():
		res = evalLeBinaryExpression(expr)

	case expr.isOr():
		res = evalOrBinaryExpression(expr)
	case expr.isAnd():
		res = evalAndBinaryExpression(expr)

    }
    if expr.isTmpExpression() {
        if res == nil {
            res = NULL
        }
        expr.addVar(expr.tmpname, res)
    }
    // 常量折叠
    if expr.left.isConst() && expr.right.isConst() {
    	expr.res = res
	}
    return res
}

func evalAndBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isBooleanValue() && right.isBooleanValue():
		tmpVal = left.bool_value && right.bool_value

	default:
		runtimeExcption("evalAndBinaryExpression Exception:", tokensString(expr.raw))
	}
	res = newVal(tmpVal)
	return res
}

func evalOrBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isBooleanValue() && right.isBooleanValue():
		tmpVal = left.bool_value || right.bool_value

	default:
		runtimeExcption("evalOrBinaryExpression Exception:", tokensString(expr.raw))
	}
	res = newVal(tmpVal)
	return res
}

func evalEqBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isBooleanValue() && right.isBooleanValue():
		tmpVal = left.bool_value == left.bool_value
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value == right.int_value
	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value == right.float_value
	case left.isStringValue() && right.isStringValue():
		tmpVal = left.str_value == right.str_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value == float64(right.int_value)
	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) == right.float_value

	default:
		tmpVal = false
	}
	res = newVal(tmpVal)
	return res
}

func evalGtBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value > right.int_value
	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value > right.float_value
	case left.isStringValue() && right.isStringValue():
		tmpVal = left.str_value > right.str_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value > float64(right.int_value)
	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) > right.float_value

	default:
		tmpVal = false
	}
	res = newVal(tmpVal)
	return res
}

func evalLtBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value < right.int_value
	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value < right.float_value
	case left.isStringValue() && right.isStringValue():
		tmpVal = left.str_value < right.str_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value < float64(right.int_value)
	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) < right.float_value

	default:
		tmpVal = false
	}
	res = newVal(tmpVal)
	return res
}

func evalGeBinaryExpression(expr *Expression) (res *Value) {
	tmpVal := evalGtBinaryExpression(expr).bool_value || evalEqBinaryExpression(expr).bool_value
	res = newVal(tmpVal)
	return res
}

func evalLeBinaryExpression(expr *Expression) (res *Value) {
	tmpVal := evalLtBinaryExpression(expr).bool_value || evalEqBinaryExpression(expr).bool_value
	res = newVal(tmpVal)
	return res
}

func evalAssignAfterAddBinaryExpression(expr *Expression) (res *Value) {
	res = evalAddBinaryExpression(expr)

	varname := expr.left.name
	expr.addVar(varname, res)
	return res
}

func evalAssignAfterSubBinaryExpression(expr *Expression) (res *Value) {
	res = evalSubBinaryExpression(expr)

	varname := expr.left.name
	expr.addVar(varname, res)
	return res
}

func evalAssignAfterMulBinaryExpression(expr *Expression) (res *Value) {
	res = evalMulBinaryExpression(expr)

	varname := expr.left.name
	expr.addVar(varname, res)
	return res
}

func evalAssignAfterDivBinaryExpression(expr *Expression) (res *Value) {
	res = evalDivBinaryExpression(expr)

	varname := expr.left.name
	expr.addVar(varname, res)
	return res
}

func evalAssignAfterModBinaryExpression(expr *Expression) (res *Value) {
	res = evalModBinaryExpression(expr)

	varname := expr.left.name
	expr.addVar(varname, res)
	return res
}

func evalAssignBinaryExpression(expr *Expression) (res *Value) {
	primaryExpr := expr.left
	res = expr.rightVal()

	varname := primaryExpr.name
	if primaryExpr.isElement() {
		arrRawVal := expr.searchArrayVariable(varname)
		argVals := toGoTypeValues(primaryExpr.args, expr.vars)
		argRawVals := getArrayIndexs(len(arrRawVal), argVals)

		arrRawVal[argRawVals[0]] = res.val()
		res = newVal(arrRawVal)
	}else if primaryExpr.isAttibute() {
		varname = primaryExpr.caller
		attrname := primaryExpr.name
		objVal := expr.searchVariable(varname)
		objRawVal := objVal.val.val()
		obj, ok := objRawVal.(map[string]interface{})
		if ok {
			obj[attrname] = res.val()
			res = newVal(obj)
		}
	}


	expr.addVar(varname, res)
	return res
}

func evalAddBinaryExpression(expr *Expression) (res *Value) {
    left := expr.leftVal()
    right := expr.rightVal()
	var tmpVal interface{}
    switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value + right.int_value

	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value + right.float_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value + float64(right.int_value)

	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) + right.float_value

	case left.isIntValue() && right.isStringValue():
		tmpVal = fmt.Sprintf("%v%v", left.int_value, right.str_value)
	case left.isFloatValue() && right.isStringValue():
		tmpVal = fmt.Sprintf("%v%v", left.float_value, right.str_value)
	case left.isBooleanValue() && right.isStringValue():
		tmpVal = fmt.Sprintf("%v%v", left.bool_value, right.str_value)

	case left.isStringValue() && right.isIntValue():
		tmpVal = fmt.Sprintf("%v%v", left.str_value, right.int_value)
	case left.isStringValue() && right.isFloatValue():
		tmpVal = fmt.Sprintf("%v%v", left.str_value, right.float_value)
	case left.isStringValue() && right.isBooleanValue():
		tmpVal = fmt.Sprintf("%v%v", left.str_value, right.bool_value)

	case left.isStringValue() && right.isStringValue():
		tmpVal = fmt.Sprintf("%v%v", left.str_value, right.str_value)

	default:
		runtimeExcption("unknow operation:", left.val(), "+", right.val())
    }

	res = newVal(tmpVal)
    return res
}

func evalSubBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value - right.int_value

	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value - right.float_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value - float64(right.int_value)

	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) - right.float_value

	default:
		runtimeExcption("unknow operation:", left.val(), "-", right.val())
	}
	res = newVal(tmpVal)
	return res
}

func evalMulBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()
	var tmpVal interface{}
	switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value * right.int_value

	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value * right.float_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value * float64(right.int_value)

	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) * right.float_value

	default:
		runtimeExcption("unknow operation:", left.val(), "*", right.val())
	}
	res = newVal(tmpVal)
	return res
}

func evalDivBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()

	checkDivZeroOperation(right)

	var tmpVal interface{}
	switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = left.int_value / right.int_value

	case left.isFloatValue() && right.isFloatValue():
		tmpVal = left.float_value / right.float_value

	case left.isFloatValue() && right.isIntValue():
		tmpVal = left.float_value / float64(right.int_value)

	case left.isIntValue() && right.isFloatValue():
		tmpVal = float64(left.int_value) / right.float_value

	default:
		runtimeExcption("unknow operation:", left.val(), "/", right.val())
	}
	res = newVal(tmpVal)
	return res
}

func evalModBinaryExpression(expr *Expression) (res *Value) {
	left := expr.leftVal()
	right := expr.rightVal()

	checkDivZeroOperation(right)

	var tmpVal interface{}
	switch {
	case left.isIntValue() && right.isIntValue():
		tmpVal = right.int_value % left.int_value

	default:
		runtimeExcption("unknow operation:", left.val(), "%", right.val())
	}
	res = newVal(tmpVal)
	return res
}

func checkDivZeroOperation(val *Value) {
	var flag bool
	if val.isIntValue() {
		flag = val.int_value == 0
	}
	if val.isFloatValue() {
		flag = val.float_value == 0
	}
	if flag {
		runtimeExcption("Invalid Operation: divide zero")
	}
}

func getArrayIndexs(arrSize int, objs []interface{}) []int {
	if objs == nil {
		runtimeExcption("array indexs is null:", fmt.Sprintln(objs...))
		return nil
	}
	var res []int
	for _, obj := range objs {
		var argRawVal int
		argRawVal, ok := obj.(int)
		if !ok {
			runtimeExcption("index type error:", obj)
			return nil
		}
		if argRawVal >= arrSize || argRawVal<0 {
			runtimeExcption("array index out of bounds:", argRawVal)
			return nil
		}
		res = append(res, argRawVal)
	}
	return res
}


func toGoTypeValues(exprs []*Expression, vars *VarScope) []interface{} {
    var res []interface{}
    for _, expr := range exprs {
    	//fmt.Println("expr:",expr==nil, expr,", vars:", vars, "< toGoTypeValues")
        if expr == nil {
        	continue
		}
    	expr.vars = vars
        goValue := executeExpression(expr)
        v := goValue.val()
        res = append(res, v)
    }
    return res
}

~~~~~~~~~~~~~~~~~~~~
#####src\core\json_array.go#####package core

type JSONArray interface {
    size()
    add(elem interface{})
    set(index int, elem interface{})
    get(index int) interface{}
    getValue(index int) *Value
    rawValueList() []interface{}
    ValueList() []*Value
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\json_object.go#####package core


type JSONObject interface {
    size()
    exist(key string)
    put(key string, value interface{})
    get(key string) interface{}
    getValue(key string) *Value
    keys() []string
    rawValues() []interface{}
    Values() []*Value
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\lex.go#####package core

import (
    "fmt"
)



func ParseTokens(bs []byte) []Token {
    // 提取原始token列表
    ts := parse4PrimaryTokens(bs)

    // 语法预处理
    // 提取'++', '--'等运算符
    ts = parse4OperatorTokens(ts)
    // 去掉无用的';', 合并token生成函数调用token(Fcall), 方法调用token(Mtcall)等复合token
    ts = parse4ComplexTokens(ts)
    return ts
}

// 提取多符号运算符(>=, <=...)
func parse4OperatorTokens(ts []Token) []Token {
    var res []Token
    for _, token := range ts {
        last, lastExist := lastToken(res)

        currentIsEqual := token.assertSymbol("=")
        condEqualMerge := lastExist && last.assertSymbols("=", ">", "<", "+", "-", "*", "/", "%")
        condEqual := currentIsEqual && condEqualMerge

        currentIsOr := token.assertSymbol("|")
        condOrMerge := lastExist && last.assertSymbols("|")
        condOr := currentIsOr && condOrMerge

        currentIsAnd := token.assertSymbol("&")
        condAndMerge := lastExist && last.assertSymbols("&")
        condAnd := currentIsAnd && condAndMerge

        currentIsAdd := token.assertSymbol("+")
        condAddMerge := lastExist && last.assertSymbols("+")
        condAdd := currentIsAdd && condAddMerge

        currentIsSub := token.assertSymbol("-")
        condSubMerge := lastExist && last.assertSymbols("-")
        condSub := currentIsSub && condSubMerge

        if condEqual || condAnd || condOr || condAdd || condSub {
            res = tailTokenMerge(res, token)
            if newTokens, ok := extractAddSubSelfToken(condAdd, condSub, res); ok {
                res = newTokens
            }
            continue
        }

        res = append(res, token)
    }
    return res
}

// 提取自增，自减token
func extractAddSubSelfToken(condAdd bool, condSub bool, ts []Token) (res []Token, ok bool) {
    size := len(ts)
    if (!condAdd && !condSub) || size<2 || !ts[size-2].isIdentifier() {
        // 判断自增，自减运算符是否能前一个token合并为自增，自减token
        return
    }

    var newTokenType TokenType
    if condAdd {
        newTokenType = AddSelf
    } else {
        newTokenType = SubSelf
    }
    tailIndex := size - 2
    tail := ts[tailIndex]
    tail.t = tail.t | newTokenType

    res = ts[:size-1]
    res[tailIndex] = tail

    return res, true
}

// 当前token与前一个token合并。
// 常用于提取"++", "--"这样的运算符。
func tailTokenMerge(ts []Token, t Token) []Token {
    size := len(ts)
    tail := ts[size-1]
    tail.str = fmt.Sprintf("%v%v", tail.str, t.str)
    ts[size - 1] = tail
    return ts
}

// 该函数用于： 去掉无用的';', 合并token生成函数调用token(Fcall), 方法调用token(Mtcall)等复合token
func parse4ComplexTokens(ts []Token) []Token {
    var res []Token
    size := len(ts)
    for i:=0; i<size; {
        token := ts[i]
        pre, preExist := preToken(i, ts)
        next, nextExist := nextToken(i, ts)
        var t Token
        var nextIndex int

        // 处理无用分号
        if token.str == ";" && ((preExist && pre.assertSymbols("{","}")) || (nextExist && next.assertSymbols("{", ";"))) {
            goto end_current_iterate
        }

        // 捕获数组的字面值Token
        if token.assertSymbol("[") && preExist && pre.assertSymbols("=", "(") {
            t, nextIndex = extractArrayLiteral(i+1, ts)
            if nextIndex > i {
                res = append(res, t)
                i = nextIndex
                goto next_loop
            }
        }
        // 捕获对象的字面值Token
        if token.assertSymbol("{") && preExist && pre.assertSymbols("=", "(") {
            t, nextIndex = extractObjectLiteral(i+1, ts)
            if nextIndex > i {
                res = append(res, t)
                res = append(res, symbolToken(";"))
                i = nextIndex
                goto next_loop
            }
        }

        if !token.isIdentifier() || !nextExist {
            goto token_collect
        }

        // 捕获Attribute类型token
        t, nextIndex = extractAttribute(i, ts)
        if nextIndex > i {
            // 捕获Mtcall类型token
            if nextIndex < size && ts[nextIndex].assertSymbol("(") {
                t, nextIndex = extractMethodCall(i, ts)
            }
            res = append(res, t)
            i = nextIndex
            goto next_loop
        }

        // 捕获Fcall类型token
        t, nextIndex = extractFunctionCall(i, ts)
        if nextIndex > i {
            // 标记Fdef类型token
            if nextIndex < size && ts[nextIndex].assertSymbol("{") {
                t.t = Fdef | t.t
            }
            res = append(res, t)
            i = nextIndex
            goto next_loop
        }

        // 捕获Element类型token
        t, nextIndex = extractElement(i, ts)
        if nextIndex > i {
            res = append(res, t)
            i = nextIndex
            goto next_loop
        }

        // token 原样返回
        token_collect:
        res = append(res, token)

        end_current_iterate:
        i++
        next_loop:
    }
    return res
}

func extractArrayLiteral(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    scopeOpenCount := 1
    var elems []Token
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("]") {
            scopeOpenCount --
            nextIndex = i + 1
            break
        }
        if token.isSymbol() && !match(token.str, ",") {
            msg := printCurrentPositionTokens(ts, i)
            panic("extract ArrayLiteral Exception, illegal character:" + msg)
        }
        elems = append(elems, token)
    }
    if scopeOpenCount > 0 {
        panic("extract ArrayLiteral Exception: no match final character \"]\"")
    }
    t = Token{
        str:    "[]",
        t:      ArrLiteral | Complex,
        ts:     elems,
    }
    return t, nextIndex
}

func extractObjectLiteral(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    scopeOpenCount := 1
    var elems []Token
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("{") {
            scopeOpenCount ++
        }
        if token.assertSymbol("}") {
            scopeOpenCount --
            if scopeOpenCount == 0 {
                nextIndex = i + 1
                break
            }
        }
        if token.isSymbol() && !match(token.str,",", ":", "[", "]", "{", "}") {
            msg := printCurrentPositionTokens(ts, i)
            panic("extract element ObjectLiteral, illegal character: " + msg + " -type " + token.TokenTypeName())
        }
        elems = append(elems, token)
    }
    if scopeOpenCount > 0 {
        panic("extract element ObjectLiteral: no match final character \"}\"")
    }
    t = Token{
        str:    "{}",
        t:      ObjLiteral | Complex,
        ts:     elems,
    }
    return t, nextIndex
}

func extractElement(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    // 检测不符合元素定义直接返回
    if size - currentIndex < 3 || !ts[currentIndex+1].assertSymbol("[") {
        return
    }
    var indexs []Token
    extractElementIndexTokens(currentIndex+2, ts, &nextIndex, &indexs)

    t = Token {
        str:    ts[currentIndex].str,
        t:      Element | Complex,
        ts:     indexs,
    }
    return t, nextIndex
}

func extractElementIndexTokens(currentIndex int, ts []Token, nextIndex *int, indexs *[]Token) {
    size := len(ts)
    scopeOpenCount := 1
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("]") {
            scopeOpenCount --
            *nextIndex = i + 1
            break
        }
        if token.isSymbol() && !match(token.str, "{", "}", ",", ";", "[", "=") {
            panic("extract element index Exception, illegal character:"+token.str)
        }
        *indexs = append(*indexs, token)
    }
    if scopeOpenCount > 0 {
        panic("extract element index Exception: no match final character \"]\"")
    }
    if *nextIndex < size && ts[*nextIndex].assertSymbol("[") {
        *indexs = append(*indexs, symbolToken(","))
        extractElementIndexTokens(*nextIndex+1, ts, nextIndex, indexs)
    }
}

func extractFunctionCall(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    // 检测不符合函数调用定义直接返回
    if size - currentIndex < 3 || !ts[currentIndex+1].assertSymbol("(") {
        return
    }

    args, nextIndex := getCallArgsTokens(currentIndex + 2, ts)

    t = Token{
        str:    ts[currentIndex].str,
        t:      Fcall | Complex,
        ts:     args,
    }
    return t, nextIndex
}

func extractMethodCall(currentIndex int, ts []Token) (t Token, nextIndex int) {
    args, nextIndex := getCallArgsTokens(currentIndex + 4, ts)

    t = Token{
        str:    ts[currentIndex+2].str,
        t:      Mtcall | Complex,
        caller: ts[currentIndex].str,
        ts:     args,
    }
    return t, nextIndex
}

func getCallArgsTokens(currentIndex int, ts []Token) (args []Token, nextIndex int) {
    size := len(ts)
    scopeOpenCount := 1
    for i := currentIndex; i < size; i++ {
        token := ts[i]
        if token.assertSymbol("(") {
            scopeOpenCount ++
        }
        if token.assertSymbol(")") {
            scopeOpenCount --
            if scopeOpenCount == 0 {
                nextIndex = i + 1
                break
            }
        }
        if token.assertSymbols("{", "}", ";", "=") {
            msg := printCurrentPositionTokens(ts, i)
            panic("extract call args Exception, illegal character:"+msg)
        }
        args = append(args, token)
    }
    if scopeOpenCount > 0 {
        panic("extract call args Exception: no match final character \")\"")
    }
    return args, nextIndex
}

func extractAttribute(currentIndex int, ts []Token) (t Token, nextIndex int) {
    size := len(ts)
    if size - currentIndex < 3 {
        return
    }
    if !ts[currentIndex+1].assertSymbol(".")  || !ts[currentIndex+2].isIdentifier() {
        return
    }

    token := Token{
        str:    ts[currentIndex+2].str,
        t:      Attribute | Complex,
        caller: ts[currentIndex].str,
    }
    return token, currentIndex+3
}

func preToken(currentIndex int, ts []Token) (t Token, ok bool) {
    if currentIndex-1 < 0 {
        return
    }
    return ts[currentIndex-1], true
}

func lastToken(ts []Token) (t Token, ok bool) {
    size := len(ts)
    if size < 1 {
        return
    }
    return ts[size-1], true
}

func nextToken(currentIndex int, ts []Token) (t Token, ok bool) {
    if currentIndex+1>=len(ts) {
        return
    }
    return ts[currentIndex+1], true
}

var lineIndex = 1 //行索引，用于定位错误。（每个token都会记录自己的行索引）

// 状态机解析原始token用
const (
    stateStr int = 1 << iota
    stateStrLiteral
    stateInt
    stateDot
    stateFloat
    stateSymbol
    stateSpace

    statePreComment
    stateSingleLineComment
    stateMutliLineComment

    stateNormal
)

// 提取原始token, 并去掉注释
func parse4PrimaryTokens(bs []byte) []Token {
    var tokens []Token
    var tmp []byte
    state := stateNormal

    for i, b := range bs {

        if state == stateSingleLineComment && b != '\n' {
            continue
        }
        if state == stateMutliLineComment && b != '/' {
            continue
        }
        if state == stateStrLiteral && b != '"' {
            tmp = append(tmp, b)
            continue
        }

        switch {
        case (b>='a' && b<='z') || (b>='A' && b<='Z') || b=='_':
            tmp = append(tmp, b)
            state = stateStr

        case b>='0' && b<='9':
            tmp = append(tmp, b)
            if state == stateDot {
                state = stateFloat
            }else{
                state = stateInt
            }

        case b==' ' || b=='\t' || b =='\n':
            pushLongToken(b, state, &tmp, &tokens)

            state = stateSpace
            if b=='\n' {
                if state == stateSingleLineComment {
                    state = stateNormal
                } else {
                    pushBoundryToken(&tokens)
                }
                lineIndex++
            }

        case isSymbol(b):
            //fmt.Println("symbol:", string(b))
            if b == '.' && state==stateInt {
                tmp = append(tmp, b)
                state = stateDot
                break
            }

            pushLongToken(b, state, &tmp, &tokens)

            tokens = pushSymbolToken(b, tokens)
            state = stateSymbol

        case b == '"':
            // 处理字符串字面值
            if len(tmp) < 1 {
                state = stateStrLiteral
            } else {
                if tmp[len(tmp)-1] != '\\' {
                    pushLongToken(b, state, &tmp, &tokens)
                    state = stateNormal
                } else {
                    tmp = append(tmp, b)
                }
            }

        case b == '/':
            pushLongToken(b, state, &tmp, &tokens)
            if state != stateMutliLineComment && state != statePreComment {
                tokens = pushSymbolToken(b, tokens)
            }
            if newState, ok := commentCheck(state, bs, i); ok {
                state = newState
            }
            if state == stateSingleLineComment {
                tailTokenClear(&tokens)
            }

        case b == '*':
            if state == statePreComment {
                state = stateMutliLineComment
                tailTokenClear(&tokens)
            }
        }
    }
    pushLongToken('\n', state, &tmp, &tokens)
    pushBoundryToken(&tokens)

    return tokens
}

func tailTokenClear(ts *[]Token) {
    size := len(*ts)
    if size < 1 {
        return
    }
    *ts = (*ts)[:size-1]
}

func commentCheck(state int, bs []byte, i int) (int, bool) {
    var newState int
    var ok bool
    //fmt.Println("commentCheck",state != statePreComment && state != stateSingleLineComment && state != stateMutliLineComment)
    if state != statePreComment && state != stateSingleLineComment && state != stateMutliLineComment {
        newState = statePreComment
    } else {
        if state == statePreComment {
            newState = stateSingleLineComment
        }
        if state == stateMutliLineComment && bs[i-1] == '*' {
            newState = stateNormal
        }
    }
    if newState > 0 {
        ok = true
    }
    return newState, ok
}

func pushSymbolToken(b byte, ts []Token) []Token {
    symbol := symbolToken(string(b))
    symbol.lineIndex = lineIndex
    last, lastExist := lastToken(ts)
    if symbol.assertSymbol("}") && lastExist && last.assertSymbol(";") {
        // 去掉无用的";"
        ts[len(ts)-1] = symbol
    } else {
        ts = append(ts, symbol)
    }
    return ts
}

func pushBoundryToken(ts *[]Token) {
    size := len(*ts)
    if size>0 && (*ts)[size-1].assertSymbols("{", ",", "}") {
        // 防止添加无用的";"
        return
    }

    *ts = append(*ts, Token{
        lineIndex:lineIndex,
        str: ";",
        t:   Symbol,
    })
}

func pushLongToken(b byte, state int, tmp *[]byte, tokens *[]Token) {
    s := string(*tmp)
    if len(s) < 1 {
        return
    }

    var tokenType TokenType
    if state == stateFloat {
        tokenType = Float
    }
    if state == stateInt && b != '.' {
        tokenType = Int
    }
    if state == stateStr {
        tokenType = Identifier
    }
    if state == stateStrLiteral {
        tokenType = Str
    }
    *tokens = append(*tokens, Token{
        lineIndex:lineIndex,
        str: s,
        t:   tokenType,
    })
    // 重置临时变量
    *tmp = nil
}

func isSymbol(b byte) bool {
    switch b {
    case '.': fallthrough
    case ':': fallthrough
    case '(': fallthrough
    case ')': fallthrough
    case '[': fallthrough
    case ']': fallthrough
    case '{': fallthrough
    case '}': fallthrough
    case ';': fallthrough
    case ',': fallthrough
    case '=': fallthrough
    case '+': fallthrough
    case '-': fallthrough
    case '*': fallthrough
    //case '/': fallthrough 因涉及注释，独立处理
    case '%': fallthrough
    case '>': fallthrough
    case '<':
        return true
    }
    return false
}





~~~~~~~~~~~~~~~~~~~~
#####src\core\lex_test.go#####package core

~~~~~~~~~~~~~~~~~~~~
#####src\core\primaryExpression.go#####package core



type PrimaryExpressionType int
const (
	VarPrimaryExpressionType PrimaryExpressionType = 1 << iota
	ConstPrimaryExpressionType
	ElementPrimaryExpressionType
	AttibutePrimaryExpressionType
	OtherPrimaryExpressionType PrimaryExpressionType = 0
)

type PrimaryExpr struct {
	t PrimaryExpressionType
	caller string // 调用者名称
	name string  // 变量名或者函数名称
	args []*Expression // 参数变量名
	res *Value  // 常量值
}

func (this *PrimaryExpr) isVar() bool {
	return (this.t & VarPrimaryExpressionType) == VarPrimaryExpressionType
}

func (this *PrimaryExpr) isConst() bool {
	return (this.t & ConstPrimaryExpressionType) == ConstPrimaryExpressionType
}

func (this *PrimaryExpr) isElement() bool {
	return (this.t & ElementPrimaryExpressionType) == ElementPrimaryExpressionType
}

func (this *PrimaryExpr) isAttibute() bool {
	return (this.t & AttibutePrimaryExpressionType) == AttibutePrimaryExpressionType
}

func (this *PrimaryExpr) isOther() bool {
	return (this.t & OtherPrimaryExpressionType) == OtherPrimaryExpressionType
}


~~~~~~~~~~~~~~~~~~~~
#####src\core\statement.go#####package core

import (
    "bytes"
)

type StatementType int

const (
    ExpressionStatement StatementType = 1 << iota
    IfStatement
    ForStatement
    SwitchStatement
    ReturnStatement
)


type Statement struct {
    t StatementType
    tmpcount int
    exprs []*Expression
    preExpr *Expression
    condition *Expression
    postExpr *Expression
    block []*Statement
    raw []Token // token列表
    compiled bool
}


func (stmt *Statement) addStatement(stm *Statement) {
    stmt.block = append(stmt.block, stm)
}

func (stmt *Statement) stmts() []*Statement {
    return stmt.block
}

func (stmt *Statement) getRaw() []Token {
    return stmt.raw
}

func (stmt *Statement) setRaw(ts []Token) {
    stmt.raw = ts
}

func (stmt *Statement) isCompiled() bool {
    return stmt.compiled
}

func (stmt *Statement) setCompiled(flag bool) {
    stmt.compiled = flag
}


func (s *Statement) setHeaderInfo(exprs []*Expression) {
    s.preExpr = exprs[0]
    s.condition = exprs[1]
    s.postExpr = exprs[2]
}

func (s *Statement) addExpression(expr *Expression) {
    if len(s.exprs)>0 && s.exprs[len(s.exprs)-1].isMultiExpression() && !(s.exprs[len(s.exprs)-1].listFinish) {
        lastExpr := s.exprs[len(s.exprs)-1]
        subExprs := &lastExpr.list

        if expr.isMultiExpression() {
            expr = expr.list[0]
        }

        *subExprs = append(*subExprs, expr)

        if !expr.isTmpExpression() {
            lastExpr.listFinish = true
        }
        return
    }
    s.exprs = append(s.exprs, expr)
}

func (s *Statement) isExpressionStatement() bool {
    return (s.t & ExpressionStatement) == ExpressionStatement
}

func (s *Statement) isIfStatement() bool {
    return (s.t & IfStatement) == IfStatement
}

func (s *Statement) isForStatement() bool {
    return (s.t & ForStatement) == ForStatement
}

func (s *Statement) isSwitchStatement() bool {
    return (s.t & SwitchStatement) == SwitchStatement
}

func (s *Statement) isReturnStatement() bool {
    return (s.t & ReturnStatement) == ReturnStatement
}


func (s *Statement) String() string {
    var res bytes.Buffer
    if s.isReturnStatement() {
        res.WriteString(" return: ")
    }
    for _, t := range s.raw {
        res.WriteString(t.String())
        res.WriteString(" ")
    }
    if (s.t & IfStatement) == IfStatement {
        res.WriteString("condition:")
        res.WriteString(s.condition.String())
        res.WriteString(" ")
    }
    if (s.t & ForStatement) == ForStatement {
        res.WriteString("header:")
        res.WriteString(s.preExpr.String())
        res.WriteString("; ")
        res.WriteString(s.condition.String())
        res.WriteString("; ")
        res.WriteString(s.postExpr.String())
        res.WriteString(" ")
    }
    return res.String()
}

func newStatement(t StatementType, ts []Token) *Statement {
    return &Statement{
        t:     t,
        exprs: nil,
        raw:   ts,
    }
}








~~~~~~~~~~~~~~~~~~~~
#####src\core\statement_list.go#####package core

type StatementList interface {
	stmts() []*Statement
	addStatement(*Statement)
	getRaw() []Token
	setRaw([]Token)
	isCompiled() bool
	setCompiled(bool)
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\statement_result.go#####package core


type StatementResultType int

const (
	StatementReturn StatementResultType = 1 << iota
	StatementContinue
	StatementBreak
	StatementNormal
)

type StatementResult struct {
	t StatementResultType
	val Value
}

func (this *StatementResult) isStatementReturn() bool {
	return (this.t & StatementReturn) == StatementReturn
}

func (this *StatementResult) isStatementContinue() bool {
	return (this.t & StatementContinue) == StatementContinue
}

func (this *StatementResult) isStatementBreak() bool {
	return (this.t & StatementBreak) == StatementBreak
}

func (this *StatementResult) isStatementNormal() bool {
	return (this.t & StatementNormal) == StatementNormal
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\token.go#####package core

import (
	"bytes"
	"fmt"
	"strings"
)

type TokenType int
const (
	Identifier  TokenType = 1 << iota // 标识符
	Str // 字符串类型
	Int // 整数类型
	Float  // 浮点类型
	Symbol  // 符号

	Fcall  // 函数调用
	Fdef  // 函数 定义
	Mtcall // 方法调用
	Attribute // 对象属性
	ArrLiteral // 数组字面值
	ObjLiteral // 对象字面值
	Element // 元素，用于指示对象或数组的元素
	Complex // 用于标记复合类型token

	AddSelf // 自增一
	SubSelf // 自减一

	Tmp // 语法分析时，插入的临时变量名
)

type Token struct {
	lineIndex int
	str string
	t TokenType
	caller string
	ts []Token
}

func newToken(raw string, t TokenType) Token {
	return Token{str:raw,t:t}
}

func symbolToken(s string) Token {
	return Token{str:s, t:Symbol}
}

func varToken(s string) Token {
	return Token{str:s, t:Identifier}
}

func (this *Token) isIdentifier() bool {
	return (this.t & Identifier) == Identifier
}

func (this *Token) isStr() bool {
	return (this.t & Str) == Str
}

func (this *Token) isInt() bool {
	return (this.t & Int) == Int
}

func (this *Token) isFloat() bool {
	return (this.t & Float) == Float
}

func (this *Token) isSymbol() bool {
	return (this.t & Symbol) == Symbol
}

func (this *Token) isTmp() bool {
	return (this.t & Tmp) == Tmp
}

func (this *Token) isFdef() bool {
	return (this.t & Fdef) == Fdef
}

func (this *Token) isFcall() bool {
	return (this.t & Fcall) == Fcall
}

func (this *Token) isAttribute() bool {
	return (this.t & Attribute) == Attribute
}

func (this *Token) isMtcall() bool {
	return (this.t & Mtcall) == Mtcall
}

func (this *Token) isArrLiteral() bool {
	return (this.t & ArrLiteral) == ArrLiteral
}

func (this *Token) isObjLiteral() bool {
	return (this.t & ObjLiteral) == ObjLiteral
}

func (this *Token) isElement() bool {
	return (this.t & Element) == Element
}

func (this *Token) isComplex() bool {
	return (this.t & Complex) == Complex
}

func (this *Token) isAddSelf() bool {
	return (this.t & AddSelf) == AddSelf
}

func (this *Token) isSubSelf() bool {
	return (this.t & SubSelf) == SubSelf
}

func (this *Token) assertSymbol(s string) bool {
	return this.isSymbol() && this.str == s
}

func (this *Token) assertSymbols(ss ...string) bool {
	if !this.isSymbol(){
		return false
	}
	for _, s := range ss {
		if s == this.str {
			return true
		}
	}
	return false
}

// 获取运算符优先级
// （注：运算符的优先级，值越小，优先级越高）
func (this *Token) priority() int {
	res := -1

	if !this.isSymbol() {
		return res
	}

	switch {
	//case this.assertSymbols("(", ")", "[","]", "."):
	//    res = 1
	//case this.assertSymbols("!", "+", "-", " ", "++", "--"):
	//! +(正)  -(负)   ++ -- , 结合性：从右向左
	//res = 2
	case this.assertSymbols("*", "/", "%"):
		res = 3
	case this.assertSymbols("+", "-"):
		// +(加) -(减)
		res = 4
	case this.assertSymbols("<<", ">>", ">>>"):
		res = 5
	case this.assertSymbols("<", "<=", ">", ">="):
		res = 6
	case this.assertSymbols("==", "!="):
		res = 7
	case this.assertSymbols("&"):
		// (按位与)
		res = 8
	case this.assertSymbols("^"):
		res = 9
	case this.assertSymbols("|"):
		res = 10
	case this.assertSymbols("&&"):
		res = 11
	case this.assertSymbols("||"):
		res = 12
	case this.assertSymbols("?:"):
		//  结合性：从右向左
		res = 13
	case this.assertSymbols("=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", " =", "<<=", ">>=", ">>>="):
		// 结合性：从右向左
		res = 14
	}
	return res
}

func isValidPriorityCompared(t1, t2 *Token) bool {
	if t1.priority() == -1 || t2.priority() == -1 {
		return false
	}
	return true
}

func (this *Token) equal(t *Token) bool {
	return isValidPriorityCompared(this,t) && this.priority() == t.priority()
}

func (this *Token) lower(t *Token) bool {
	return isValidPriorityCompared(this,t) && this.priority() < t.priority()
}

func (this *Token) upper(t *Token) bool {
	return isValidPriorityCompared(this,t) && this.priority() > t.priority()
}

func (this *Token) String() string {
	if this.isArrLiteral() || this.isObjLiteral() {
		return this.toJSONString()
	}

	if this.isFcall() || this.isFdef() {
		var buf bytes.Buffer
		buf.WriteString(this.str)
		buf.WriteString("(")
		if this.ts != nil {
			for _, token := range this.ts {
				buf.WriteString(token.String())
			}
		}
		buf.WriteString(")")
		return buf.String()
	}

	if this.isAttribute() || this.isMtcall() {
		var buf bytes.Buffer
		buf.WriteString(this.caller)
		buf.WriteString(".")
		buf.WriteString(this.str)
		if this.isMtcall() {
			buf.WriteString("(")
			if this.ts != nil {
				for _, token := range this.ts {
					buf.WriteString(token.String())
				}
			}
			buf.WriteString(")")
		}
		return buf.String()
	}

	if this.isElement() {
		var buf bytes.Buffer
		buf.WriteString(this.str)
		buf.WriteString("[")
		if this.ts != nil {
			for _, token := range this.ts {
				buf.WriteString(token.String())
			}
		}
		buf.WriteString("]")
		return buf.String()
	}

	if this.isStr() {
		return fmt.Sprintf(`"%v"`, this.str)
	}

	if this.isAddSelf() {
		return fmt.Sprintf(`%v ++`, this.str)
	}

	if this.isSubSelf() {
		return fmt.Sprintf(`%v --`, this.str)
	}

	return this.str
}

func (this *Token) toJSONString() string {
	if this.isArrLiteral() {
		var buf bytes.Buffer
		buf.WriteString("[")
		if this.ts != nil {
			for _, token := range this.ts {
				if token.isStr() {
					buf.WriteString(fmt.Sprintf(`"%v"`, token.str))
				} else {
					buf.WriteString(token.str)
				}
			}
		}
		buf.WriteString("]")
		return buf.String()
	}

	if this.isObjLiteral() {
		var buf bytes.Buffer
		buf.WriteString("{")
		if this.ts != nil {
			for _, token := range this.ts {
				if token.isStr() || token.isIdentifier() {
					buf.WriteString(fmt.Sprintf(`"%v"`, token.str))
				} else {
					buf.WriteString(token.str)
				}
			}
		}
		buf.WriteString("}")
		return buf.String()
	}
	return ""
}

func (t *Token) TokenTypeName() string {
	var buf bytes.Buffer
	if t.isStr() {
		buf.WriteString( "string, ")
	}
	if t.isIdentifier() {
		buf.WriteString( "identifier, ")
	}
	if t.isInt() {
		buf.WriteString( "int, ")
	}
	if t.isFloat() {
		buf.WriteString( "float, ")
	}
	if t.isSymbol() {
		buf.WriteString( "symbol, ")
	}
	if t.isFdef() {
		buf.WriteString("function define, ")
	}
	if t.isFcall() {
		buf.WriteString("function call, ")
	}
	if t.isMtcall() {
		buf.WriteString("method call, ")
	}
	if t.isAttribute() {
		buf.WriteString("attribute, ")
	}
	if t.isArrLiteral() {
		buf.WriteString("array literal, ")
	}
	if t.isObjLiteral() {
		buf.WriteString("object literal, ")
	}
	if t.isElement() {
		buf.WriteString("element, ")
	}
	if t.isComplex() {
		buf.WriteString("complex, ")
	}

	if t.isAddSelf() {
		buf.WriteString("addself, ")
	}
	if t.isSubSelf() {
		buf.WriteString("subself, ")
	}
	if buf.Len() == 0 {
		return "undefined"
	}
	return strings.TrimRight(strings.TrimSpace(buf.String()), ",")
}

func toString4Tokens(ts []Token, start, end int) string {
	var buf bytes.Buffer
	for i:=start; i<=end; i++ {
		token := ts[i]
		buf.WriteString(token.String()+" ")
	}
	return buf.String()
}

func tokensString(ts []Token) string {
	var buf bytes.Buffer
	for _, t := range ts {
		buf.WriteString(t.String() + "  ")
	}
	return buf.String()
}

func printCurrentPositionTokens(ts []Token, currentIndex int) string {
	size := len(ts)
	start := 0
	if currentIndex > 10 {
		start = currentIndex - 10
	}
	end := currentIndex
	if currentIndex+1 < size {
		end = currentIndex+1
	}
	return toString4Tokens(ts, start, end)
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\util.go#####package core

import (
    "fmt"
    "os"
)

func match(src string, targets ...string) bool {
    for _, target := range targets {
        if src == target {
            return true
        }
    }
    return false
}

func assert(flag bool, msg ...interface{})  {
    if flag {
        runtimeExcption(msg)
    }
}

func runtimeExcption(raw ...interface{}){
    var msg []interface{}
    for _, item := range raw {
        if err, ok := item.(error); ok && err != nil {
            msg = append(msg, err.Error())
            continue
        }
        msg = append(msg, item)
    }
    if DEBUG_MODE {
        panic(fmt.Sprintln(msg...))
        return
    }
    fmt.Println(msg...)
    os.Exit(2)
}

func insert(h Token, ts []Token) []Token {
    res := make([]Token, 0, len(ts)+1)
    res = append(res, h)
    for _, t := range ts {
        res = append(res, t)
    }
    return res
}

func insert2(t1, t2 Token, ts []Token) []Token {
    res := make([]Token, 0, len(ts)+2)
    res = append(res, t1)
    res = append(res, t2)
    for _, t := range ts {
        res = append(res, t)
    }
    return res
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\util_test.go#####package core

import (
	"testing"
	"fmt"
)

func TestNil(t *testing.T)  {
	var obj interface{}
	item, ok := obj.(error)
	fmt.Println(item, " <= item")
	fmt.Println(ok)
}

func TestNum(t *testing.T)  {
	fmt.Println(1%2)
	fmt.Println(2%2)
	fmt.Println(3%2)
	fmt.Println(4%2)
	fmt.Println(5%2)
}

func TestRuntimeException(t *testing.T)  {
	fmt.Println("step1")
	runtimeExcption("unknow operation:", "false", "-", "true")
	fmt.Println("final")
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\value.go#####package core

import "fmt"

type ValueType int

const (
    IntValue ValueType = 1 << iota
    FloatValue
    BooleanValue
    StringValue
    AnyValue
    ArrayValue
    ObjectValue
    NULLValue
)

// 空值
var NULL = &Value{
    t:           NULLValue,
}

type Value struct {
    t ValueType
    int_value int
    float_value float64
    bool_value bool
    str_value string
    any_value interface{}
    arr_value []interface{}
    obj_value map[string]interface{}
}

func newVal(rawVal interface{}) *Value {
    var val *Value
    switch v := rawVal.(type) {
    case int:
        val = &Value{t: IntValue, int_value: v}
    case float64:
        val = &Value{t: FloatValue, float_value: v}
    case float32:
        val = &Value{t: FloatValue, float_value: float64(v)}
    case bool:
        val = &Value{t: BooleanValue, bool_value: v}
    case string:
        val = &Value{t: StringValue, str_value: v}
    case []interface{}:
        val = &Value{t: ArrayValue, arr_value: v}
    case map[string]interface{}:
        val = &Value{t: ObjectValue, obj_value: v}
    default:
        panic(fmt.Sprintln("unknow exception when newVal:", rawVal))
    }
    return val
}


func (v *Value) val() interface{} {
    switch {
    case v.isIntValue(): return v.int_value
    case v.isFloatValue(): return v.float_value
    case v.isBooleanValue(): return v.bool_value
    case v.isStringValue(): return v.str_value
    case v.isArrayValue(): return v.arr_value
    case v.isObjectValue(): return v.obj_value
    case v.isAnyValue(): return v.any_value
    }
    return nil
}

func (v *Value) isNULL() bool {
    return (v.t & NULLValue) == NULLValue
}

func (v *Value) isIntValue() bool {
    return (v.t & IntValue) == IntValue
}

func (v *Value) isFloatValue() bool {
    return (v.t & FloatValue) == FloatValue
}

func (v *Value) isBooleanValue() bool {
    return (v.t & BooleanValue) == BooleanValue
}

func (v *Value) isStringValue() bool {
    return (v.t & StringValue) == StringValue
}

func (v *Value) isAnyValue() bool {
    return (v.t & AnyValue) == AnyValue
}

func (v *Value) isArrayValue() bool {
    return (v.t & ArrayValue) == ArrayValue
}

func (v *Value) isObjectValue() bool {
    return (v.t & ObjectValue) == ObjectValue
}











~~~~~~~~~~~~~~~~~~~~
#####src\core\value_test.go#####package core

import (
    "bufio"
    "bytes"
    "fmt"
    "os"
    "regexp"
    "strings"
    "testing"
)

func Test_totoken(t *testing.T) {
    token := newToken("true", Identifier)
    value := tokenToValue(&token)
    fmt.Println(value.bool_value)
}

func Test_map1(t *testing.T) {
    nv := newVariables()
    addVar(&nv)
    printVar(&nv)
}

func printVar(nv *Variables) {
    vr := nv.get("tk")
    fmt.Println(vr)
}

func addVar(nv *Variables) {
    nv.add(newVar("tk", "unique"))
}

type Obj struct {
    val string
}

func Test_map(t *testing.T) {

    m := make(map[string]*Obj)
    change(m)
    fetch(m)
}

func fetch(m map[string]*Obj) {
    fmt.Println(m["name"])
}

func change(m map[string]*Obj) {
    m["name"] = &Obj{"changlie"}
}

func Test_clone(t *testing.T) {
    f, _ := os.Open("d:/raw.txt")
    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if !strings.HasPrefix(line, "private") {
            continue
        }
        re := regexp.MustCompile("private\\s+\\w+\\s+(\\w+);")
        res := re.FindAllStringSubmatch(line, -1)
        fname := res[0][1]
        mt := strings.ToUpper(fname[:1]) + fname[1:]
        fmt.Printf("obj.set%v(this.%v);\n", mt, fname)
    }
}

func Test_fields(t *testing.T) {
    f, _ := os.Open("d:/raw.txt")
    scanner := bufio.NewScanner(f)
    var buf bytes.Buffer
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        re := regexp.MustCompile("`(\\w+)`")
        res := re.FindAllStringSubmatch(line, -1)
        buf.WriteString(res[0][1])
        buf.WriteString(", ")
    }
    fmt.Println(buf.String())
}

func Test_swi(t *testing.T) {
    a := 3
    a = a ^ 1
    a = a ^ 1
    switch a {
    case 3:
        fmt.Println("a == 3")
        if a > 0 {
            fmt.Println("a > 0")
            break
        }
        fmt.Println("a <= 0")

    }
}

func Test_obj(t *testing.T) {
    v1 := Value{
        t:           IntValue,
        int_value:   99,
        float_value: 0,
        bool_value:  false,
        str_value:   "",
        arr_value:   nil,
        obj_value:   nil,
    }
    v2 := v1
    v2.t = FloatValue
    v2.float_value = 3.14
    fmt.Println("v1:", v1)
    fmt.Println("v2:", v2)
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\variable.go#####package core


type Variable struct{
	name string
	val *Value
}

func newVar(name string, rawVal interface{}) *Variable {
	res := &Variable{
		name: name,
		val:  newVal(rawVal),
	}

	return res
}

func toVar(name string, rawVal *Value) *Variable {
	res := &Variable{
		name: name,
		val:  rawVal,
	}
	return res
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\variable_stack.go#####package core


type VarScope struct {
	super *Variables
	local *Variables
}

func newVarScope(super, local *Variables) *VarScope {
	return &VarScope{
		super: super,
		local: local,
	}
}
~~~~~~~~~~~~~~~~~~~~
#####src\core\variables.go#####package core


type Variables map[string]*Variable

func newVariables() Variables {
	return make(map[string]*Variable)
}

func (vs *Variables) isEmpty() bool {
	return vs == nil || len(*vs) < 1
}

func (vs *Variables) add(v *Variable) {
	(*vs)[v.name] = v
}

func (vs *Variables) get(name string) *Variable {
	if vs.isEmpty() {
		return nil
	}
	res, ok := (*vs)[name]
	if ok {
		return res
	}
	return nil
}
~~~~~~~~~~~~~~~~~~~~
#####src\qk\main.go#####package main

import "core"

func main()  {
    core.Run()
}


~~~~~~~~~~~~~~~~~~~~
#####src\qk\main_test.go#####package main

import (
    "bufio"
    "bytes"
    "fmt"
    "os"
    "regexp"
    "strings"
    "testing"
)

func Test_insertsql(t *testing.T) {
    fields := `taskId, taskName, sourceAppId, targetAppId, sourceDbType, targetDbType, taskStatus, taskGroup, description, ext, createdDate, createdBy, lastUpdateDate, lastUpdatedBy`
    var sql bytes.Buffer
    fs := strings.Split(fields, ",")
    for _, f := range fs {
        f := strings.TrimSpace(f)
        sql.WriteString(fmt.Sprintf(`<if test='%v != null'>`, f)+"\n")
        sql.WriteString(fmt.Sprintf(`and %v=#{%v}`, f, f)+"\n")
        sql.WriteString("</if>\n")
    }
    fmt.Println(sql.String())
}

func Test_compile(t *testing.T) {
    var res []interface{}
    res = append(res, 3)
    res = append(res, false)
    res = append(res, "test")
    fmt.Println(res)
    fmt.Println(res...)
    fmt.Println("successfully!")
}



func Test_fhandle2(t *testing.T) {
    tableName := "table_info"
    fmt.Printf("DROP TABLE IF EXISTS `%v`;\n", tableName)
    fmt.Printf("CREATE TABLE `%v` (\n", tableName)
    tfs := getTfs()
    //fmt.Println(len(infos), len(comments))
    for _, tf := range tfs {
        fmt.Printf("%v    COMMENT '%v', \n", tf.f, tf.c)
    }

}

type tf struct {
    f string
    c string
}

func getTfs() []tf {
    var res []tf
    f, _ := os.Open("d:/origin.txt")
    scanner := bufio.NewScanner(f)
    var comment string
    var field string
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if comment == "" && strings.HasPrefix(line, "*") {
            line = strings.TrimSpace(line[1:])
            comment = line
        }
        if comment != "" && field == "" && strings.HasPrefix(line, "private") {
            re := regexp.MustCompile(`\w+\s+(\w+);`)
            arr := re.FindAllStringSubmatch(line, -1)
            //fmt.Println("arr:", arr[0][1])
            field = arr[0][1]

            //handleInfo(field, comment)
            res = append(res, tf{field, comment})
            field = ""
            comment = ""
        }
    }
    return res
}

func Test_fhandle1(t *testing.T) {
    tableName := "table_info"
    fmt.Printf("DROP TABLE IF EXISTS `%v`;\n", tableName)
    fmt.Printf("CREATE TABLE `%v` (\n", tableName)
    infos := fieldInfos()
    comments := getComments()
    //fmt.Println(len(infos), len(comments))
    for i, info := range infos {
      fmt.Printf("%v COMMENT '%v', \n", info, comments[i])
    }

}

func getComments() []string {
    var res []string
    f, _ := os.Open("d:/origin.txt")
    scanner := bufio.NewScanner(f)
    var comment string
    var field string
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if comment == "" && strings.HasPrefix(line, "*") {
            line = strings.TrimSpace(line[1:])
            comment = line
        }
        if comment != "" && field == "" && strings.HasPrefix(line, "private") {
            re := regexp.MustCompile(`\w+\s+(\w+);`)
            arr := re.FindAllStringSubmatch(line, -1)
            //fmt.Println("arr:", arr[0][1])
            field = arr[0][1]

            //handleInfo(field, comment)
            res = append(res, comment)
            field = ""
            comment = ""
        }
    }
    return res
}

func handleInfo(field, comment string) {

    //msg := fmt.Sprintf("alter table %v modify column %v comment '%v';", tableName, field, comment)
    //fmt.Println(field, " - ", comment)
    //fmt.Println(msg)
}

func fieldInfos() []string {
    tableCreate := `
id int primary key auto_increment,
tableName varchar(100) not null,
tableTag varchar(150) not null,
taskId int,
primaryKey varchar(200),
lastUpdatedColumnName varchar(200),
schemaInfo text,
description varchar(2000),
ext varchar(200),
createdDate datetime,
createdBy varchar(150),
lastUpdatedDate datetime,
lastUpdatedBy varchar(150),
`
var res []string
scanner := bufio.NewScanner(strings.NewReader(tableCreate))
for scanner.Scan() {
    line := strings.TrimSpace(scanner.Text())
    if line == "" {
        continue
    }
    res = append(res, line[:len(line)-1])
}
return res
}

~~~~~~~~~~~~~~~~~~~~
#####start#####
export GOPATH=`pwd`

go install qk~~~~~~~~~~~~~~~~~~~~
